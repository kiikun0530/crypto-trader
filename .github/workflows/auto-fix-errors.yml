name: Auto-Fix Lambda Errors

on:
  repository_dispatch:
    types: [lambda-error]

permissions:
  contents: write
  models: read

env:
  AWS_REGION: ap-northeast-1

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_AUTO_FIX_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Extract error context
        id: error
        run: |
          cat << 'PAYLOAD_EOF' > /tmp/error_payload.json
          ${{ toJson(github.event.client_payload) }}
          PAYLOAD_EOF

          FUNCTION_NAME=$(jq -r '.function_name' /tmp/error_payload.json)
          ERROR_SUMMARY=$(jq -r '.error_summary' /tmp/error_payload.json)
          SERVICE_DIR=$(jq -r '.service_dir' /tmp/error_payload.json)
          LOG_GROUP=$(jq -r '.log_group' /tmp/error_payload.json)

          echo "function_name=${FUNCTION_NAME}" >> $GITHUB_OUTPUT
          echo "service_dir=${SERVICE_DIR}" >> $GITHUB_OUTPUT
          echo "log_group=${LOG_GROUP}" >> $GITHUB_OUTPUT

          # ã‚¨ãƒ©ãƒ¼ã‚µãƒžãƒªãƒ¼ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ï¼ˆæ”¹è¡Œä¿æŒï¼‰
          echo "${ERROR_SUMMARY}" > /tmp/error_summary.txt

          echo "=== Error Context ==="
          echo "Function: ${FUNCTION_NAME}"
          echo "Service dir: ${SERVICE_DIR}"
          head -20 /tmp/error_summary.txt

      - name: Fetch extended error logs from CloudWatch
        id: logs
        run: |
          # ç›´è¿‘30åˆ†ã®ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’å–å¾—
          START_TIME=$(( $(date +%s) * 1000 - 1800000 ))
          LOG_GROUP="${{ steps.error.outputs.log_group }}"

          aws logs filter-log-events \
            --log-group-name "${LOG_GROUP}" \
            --start-time ${START_TIME} \
            --filter-pattern "?ERROR ?Traceback ?Exception" \
            --limit 50 \
            --query "events[*].message" \
            --output text > /tmp/cloudwatch_errors.txt 2>/dev/null || true

          echo "=== CloudWatch Error Logs ==="
          head -50 /tmp/cloudwatch_errors.txt

      - name: Read source code
        id: source
        run: |
          SERVICE_DIR="${{ steps.error.outputs.service_dir }}"
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"

          if [ -f "${SERVICE_DIR}" ]; then
            echo "Reading: ${SERVICE_DIR}"
            cp "${SERVICE_DIR}" /tmp/original_source.py
          else
            echo "Service file not found: ${SERVICE_DIR}"
            echo "Searching for handler..."
            FOUND=$(find services/ -path "*${FUNCTION_NAME}*" -name "handler.py" | head -1)
            if [ -n "${FOUND}" ]; then
              echo "Found: ${FOUND}"
              echo "service_dir=${FOUND}" >> $GITHUB_OUTPUT
              cp "${FOUND}" /tmp/original_source.py
            else
              echo "No handler found for ${FUNCTION_NAME}"
              exit 1
            fi
          fi

          echo "=== Source Code (first 30 lines) ==="
          head -30 /tmp/original_source.py

      - name: Analyze and fix with Claude
        id: claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'CLAUDE_SCRIPT'
          import json
          import os
          import urllib.request

          function_name = "${{ steps.error.outputs.function_name }}"
          service_dir = "${{ steps.error.outputs.service_dir }}"

          # ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿
          with open('/tmp/original_source.py', 'r') as f:
              source_code = f.read()

          # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸èª­ã¿è¾¼ã¿
          with open('/tmp/error_summary.txt', 'r') as f:
              error_summary = f.read()

          # CloudWatchãƒ­ã‚°èª­ã¿è¾¼ã¿
          cw_logs = ""
          try:
              with open('/tmp/cloudwatch_errors.txt', 'r') as f:
                  cw_logs = f.read()[:3000]
          except:
              pass

          # Anthropic API (Claude Sonnet) å„ªå…ˆã€GitHub Models API ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          api_key = os.environ.get('ANTHROPIC_API_KEY', '')

          if api_key:
              api_url = "https://api.anthropic.com/v1/messages"
              headers = {
                  "x-api-key": api_key,
                  "anthropic-version": "2023-06-01",
                  "content-type": "application/json"
              }
              model = "claude-sonnet-4-20250514"
              use_anthropic = True
              print("Using Anthropic API (Claude Sonnet)")
          else:
              token = os.environ.get('GITHUB_TOKEN', '')
              api_url = "https://models.inference.ai.azure.com/chat/completions"
              headers = {
                  "Authorization": f"Bearer {token}",
                  "Content-Type": "application/json"
              }
              model = "gpt-4o-mini"
              use_anthropic = False
              print("Fallback: Using GitHub Models API (GPT-4o-mini)")

          prompt = f"""ã‚ãªãŸã¯AWS Lambdaã®ã‚¨ãƒ©ãƒ¼ã‚’è‡ªå‹•ä¿®å¾©ã™ã‚‹ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã™ã€‚

          ä»¥ä¸‹ã®Lambdaé–¢æ•°ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼ã‚’åˆ†æžã—ã€ä¿®æ­£ã—ãŸã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚

          ## ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸLambdaé–¢æ•°
          - é–¢æ•°å: eth-trading-{function_name}
          - ãƒ•ã‚¡ã‚¤ãƒ«: {service_dir}

          ## ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°
          ```
          {error_summary[:2000]}
          ```

          ## CloudWatchè©³ç´°ãƒ­ã‚°
          ```
          {cw_logs[:2000]}
          ```

          ## ç¾åœ¨ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰
          ```python
          {source_code}
          ```

          ## æŒ‡ç¤º
          1. ã‚¨ãƒ©ãƒ¼ã®æ ¹æœ¬åŽŸå› ã‚’åˆ†æžã—ã¦ãã ã•ã„
          2. ä¿®æ­£ã—ãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„
          3. ä½•ã‚’ä¿®æ­£ã—ãŸã‹ç°¡æ½”ã«èª¬æ˜Žã—ã¦ãã ã•ã„

          ## å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆï¼ˆåŽ³å¯†ã«å¾“ã£ã¦ãã ã•ã„ï¼‰
          ã¾ãšåˆ†æžã¨ä¿®æ­£å†…å®¹ã®èª¬æ˜Žã‚’æ›¸ãã€æ¬¡ã«ä¿®æ­£å¾Œã®ã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’ä»¥ä¸‹ã®ãƒžãƒ¼ã‚«ãƒ¼ã§å›²ã‚“ã§å‡ºåŠ›ã—ã¦ãã ã•ã„:

          ---ANALYSIS_START---
          ï¼ˆåˆ†æžã¨ä¿®æ­£å†…å®¹ã®èª¬æ˜Žï¼‰
          ---ANALYSIS_END---

          ---CODE_START---
          ï¼ˆä¿®æ­£å¾Œã®Pythonã‚³ãƒ¼ãƒ‰å…¨ä½“ï¼‰
          ---CODE_END---

          æ³¨æ„:
          - ã‚³ãƒ¼ãƒ‰ã¯å®Œå…¨ãªãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’å‡ºåŠ›ã™ã‚‹ã“ã¨ï¼ˆå·®åˆ†ã§ã¯ãªãï¼‰
          - ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚„ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã‚’æ­£ç¢ºã«ä¿ã¤ã“ã¨
          - importæ–‡ã‚’å¿˜ã‚Œãªã„ã“ã¨
          - ç’°å¢ƒå¤‰æ•°ã‚„AWSãƒªã‚½ãƒ¼ã‚¹åã¯å¤‰æ›´ã—ãªã„ã“ã¨
          - ã‚¨ãƒ©ãƒ¼ã«ç„¡é–¢ä¿‚ãªå¤‰æ›´ã¯åŠ ãˆãªã„ã“ã¨
          """

          if use_anthropic:
              request_body = {
                  "model": model,
                  "max_tokens": 8192,
                  "messages": [{"role": "user", "content": prompt}]
              }
          else:
              request_body = {
                  "model": model,
                  "max_tokens": 8192,
                  "messages": [
                      {"role": "system", "content": "You are an expert AWS Lambda error fixer."},
                      {"role": "user", "content": prompt}
                  ]
              }

          req = urllib.request.Request(
              api_url,
              data=json.dumps(request_body).encode('utf-8'),
              headers=headers,
              method='POST'
          )

          try:
              response = urllib.request.urlopen(req, timeout=120)
              result = json.loads(response.read().decode('utf-8'))

              if use_anthropic:
                  content = result['content'][0]['text']
              else:
                  content = result['choices'][0]['message']['content']

              print("=== Claude Response (first 500 chars) ===")
              print(content[:500])

              # åˆ†æžéƒ¨åˆ†ã‚’æŠ½å‡º
              analysis = ""
              if '---ANALYSIS_START---' in content and '---ANALYSIS_END---' in content:
                  analysis = content.split('---ANALYSIS_START---')[1].split('---ANALYSIS_END---')[0].strip()

              # ã‚³ãƒ¼ãƒ‰éƒ¨åˆ†ã‚’æŠ½å‡º
              if '---CODE_START---' in content and '---CODE_END---' in content:
                  fixed_code = content.split('---CODE_START---')[1].split('---CODE_END---')[0].strip()

                  # Pythonã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒžãƒ¼ã‚«ãƒ¼ã‚’é™¤åŽ»
                  if fixed_code.startswith('```python'):
                      fixed_code = fixed_code[len('```python'):].strip()
                  if fixed_code.startswith('```'):
                      fixed_code = fixed_code[3:].strip()
                  if fixed_code.endswith('```'):
                      fixed_code = fixed_code[:-3].strip()

                  with open('/tmp/fixed_source.py', 'w') as f:
                      f.write(fixed_code + '\n')

                  with open('/tmp/analysis.txt', 'w') as f:
                      f.write(analysis)

                  print("\n=== Analysis ===")
                  print(analysis[:500])
                  print("\n=== Fixed code written successfully ===")

                  # å·®åˆ†ç”Ÿæˆ
                  import subprocess
                  diff_result = subprocess.run(
                      ['diff', '-u', '/tmp/original_source.py', '/tmp/fixed_source.py'],
                      capture_output=True, text=True
                  )
                  with open('/tmp/diff.txt', 'w') as f:
                      f.write(diff_result.stdout)

                  print("\n=== Diff ===")
                  print(diff_result.stdout[:1000])

              else:
                  print("ERROR: Could not extract fixed code from Claude response")
                  print("Full response:")
                  print(content)
                  with open('/tmp/analysis.txt', 'w') as f:
                      f.write(f"ã‚³ãƒ¼ãƒ‰æŠ½å‡ºå¤±æ•—ã€‚Claudeå¿œç­”:\n{content[:2000]}")
                  exit(1)

          except Exception as e:
              print(f"Claude API call failed: {e}")
              with open('/tmp/analysis.txt', 'w') as f:
                  f.write(f"Claude APIå‘¼ã³å‡ºã—å¤±æ•—: {str(e)}")
              exit(1)

          CLAUDE_SCRIPT

      - name: Validate fixed code (syntax check)
        id: validate
        run: |
          echo "=== Syntax Check ==="
          python3 -c "
          import py_compile
          try:
              py_compile.compile('/tmp/fixed_source.py', doraise=True)
              print('Syntax OK')
          except py_compile.PyCompileError as e:
              print(f'Syntax Error: {e}')
              exit(1)
          "

      - name: Apply fix
        run: |
          SERVICE_DIR="${{ steps.error.outputs.service_dir }}"
          cp /tmp/fixed_source.py "${SERVICE_DIR}"
          echo "Fixed code applied to ${SERVICE_DIR}"

      - name: Deploy to AWS Lambda
        id: deploy
        run: |
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"
          LAMBDA_NAME="eth-trading-${FUNCTION_NAME}"
          SERVICE_DIR="services/${FUNCTION_NAME}"

          echo "Packaging ${SERVICE_DIR}..."
          cd "${SERVICE_DIR}"
          zip -r /tmp/lambda_deploy.zip .
          cd -

          echo "Deploying to ${LAMBDA_NAME}..."
          aws lambda update-function-code \
            --function-name "${LAMBDA_NAME}" \
            --zip-file fileb:///tmp/lambda_deploy.zip \
            --output json > /tmp/deploy_result.json

          echo "Deploy complete"
          jq '.LastModified, .CodeSha256' /tmp/deploy_result.json

      - name: Verify deployment
        id: verify
        run: |
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"
          LAMBDA_NAME="eth-trading-${FUNCTION_NAME}"

          echo "Waiting 10 seconds for deployment to stabilize..."
          sleep 10

          # Lambdaé–¢æ•°ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
          STATE=$(aws lambda get-function-configuration \
            --function-name "${LAMBDA_NAME}" \
            --query "State" --output text)
          echo "Lambda state: ${STATE}"

          if [ "${STATE}" != "Active" ]; then
            echo "Lambda is not Active, waiting..."
            aws lambda wait function-active --function-name "${LAMBDA_NAME}"
          fi

          # ç›´è¿‘ã®ã‚¨ãƒ©ãƒ¼ã‚’ç¢ºèªï¼ˆãƒ‡ãƒ—ãƒ­ã‚¤å¾Œ2åˆ†ä»¥å†…ï¼‰
          sleep 30
          DEPLOY_TIME=$(( $(date +%s) * 1000 - 30000 ))
          LOG_GROUP="/aws/lambda/${LAMBDA_NAME}"

          ERRORS=$(aws logs filter-log-events \
            --log-group-name "${LOG_GROUP}" \
            --start-time ${DEPLOY_TIME} \
            --filter-pattern "?ERROR ?Traceback ?Exception" \
            --query "events[*].message" \
            --output text 2>/dev/null || echo "")

          if [ -n "${ERRORS}" ] && [ "${ERRORS}" != "None" ]; then
            echo "âš ï¸ Post-deploy errors detected:"
            echo "${ERRORS}" | head -10
            echo "verify_status=warning" >> $GITHUB_OUTPUT
          else
            echo "âœ… No errors detected after deployment"
            echo "verify_status=success" >> $GITHUB_OUTPUT
          fi

      - name: Notify Slack (result)
        if: always()
        run: |
          python3 << 'SLACK_SCRIPT'
          import json
          import urllib.request
          import os

          webhook_url = "${{ secrets.SLACK_WEBHOOK_URL }}"
          if not webhook_url:
              print("No Slack webhook URL")
              exit(0)

          function_name = "${{ steps.error.outputs.function_name }}"
          verify_status = "${{ steps.verify.outputs.verify_status }}"
          job_status = "${{ job.status }}"

          # åˆ†æžçµæžœèª­ã¿è¾¼ã¿
          analysis = "ï¼ˆåˆ†æžæƒ…å ±ãªã—ï¼‰"
          try:
              with open('/tmp/analysis.txt', 'r') as f:
                  analysis = f.read()[:1000]
          except:
              pass

          # å·®åˆ†èª­ã¿è¾¼ã¿
          diff_text = "ï¼ˆå·®åˆ†ãªã—ï¼‰"
          try:
              with open('/tmp/diff.txt', 'r') as f:
                  diff_text = f.read()[:1500]
          except:
              pass

          if job_status == "success" and verify_status == "success":
              emoji = "âœ…"
              status_text = "è‡ªå‹•ä¿®å¾©æˆåŠŸ"
              color = "#36a64f"
          elif job_status == "success" and verify_status == "warning":
              emoji = "âš ï¸"
              status_text = "ä¿®å¾©æ¸ˆã¿ï¼ˆãƒ‡ãƒ—ãƒ­ã‚¤å¾Œã«ã‚¨ãƒ©ãƒ¼æ¤œå‡ºã‚ã‚Šï¼‰"
              color = "#ff9900"
          else:
              emoji = "âŒ"
              status_text = "è‡ªå‹•ä¿®å¾©å¤±æ•— - æ‰‹å‹•å¯¾å¿œãŒå¿…è¦"
              color = "#ff0000"

          payload = {
              "blocks": [
                  {
                      "type": "header",
                      "text": {
                          "type": "plain_text",
                          "text": f"{emoji} Auto-Fix: {function_name}"
                      }
                  },
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"*ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:* {status_text}\n*é–¢æ•°:* `eth-trading-{function_name}`"
                      }
                  },
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"*ðŸ” åˆ†æž:*\n{analysis[:800]}"
                      }
                  },
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"*ðŸ“ å¤‰æ›´å·®åˆ†:*\n```{diff_text[:1200]}```"
                      }
                  }
              ]
          }

          req = urllib.request.Request(
              webhook_url,
              data=json.dumps(payload).encode('utf-8'),
              headers={'Content-Type': 'application/json'}
          )
          try:
              response = urllib.request.urlopen(req, timeout=10)
              print(f"Slack notification sent: {response.status}")
          except Exception as e:
              print(f"Slack notification failed: {e}")

          SLACK_SCRIPT

      - name: Commit and push fix
        if: success() && steps.verify.outputs.verify_status == 'success'
        run: |
          git config user.name "auto-fix-bot"
          git config user.email "auto-fix-bot@users.noreply.github.com"

      - name: Update docs if needed
        if: success() && steps.verify.outputs.verify_status == 'success'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python3 << 'DOCS_SCRIPT'
          import json
          import os
          import urllib.request
          import glob

          function_name = "${{ steps.error.outputs.function_name }}"

          # å·®åˆ†èª­ã¿è¾¼ã¿
          try:
              with open('/tmp/diff.txt', 'r') as f:
                  diff_text = f.read()
          except:
              print("No diff found, skipping docs update")
              exit(0)

          diff_lines = len(diff_text.strip().split('\n'))
          if diff_lines < 5:
              print(f"Small change ({diff_lines} lines), skipping docs update")
              exit(0)

          # åˆ†æžçµæžœèª­ã¿è¾¼ã¿
          analysis = ""
          try:
              with open('/tmp/analysis.txt', 'r') as f:
                  analysis = f.read()
          except:
              pass

          # ä¿®æ­£å¾Œã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰
          try:
              with open('/tmp/fixed_source.py', 'r') as f:
                  fixed_code = f.read()
          except:
              print("No fixed source found, skipping")
              exit(0)

          # é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ¤œç´¢
          doc_files = {}
          for doc_path in glob.glob('docs/*.md'):
              with open(doc_path, 'r') as f:
                  content = f.read()
              # é–¢æ•°åã¾ãŸã¯ã‚µãƒ¼ãƒ“ã‚¹åãŒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹
              if function_name in content or function_name.replace('-', '_') in content:
                  doc_files[doc_path] = content

          # README.mdã‚‚ç¢ºèª
          try:
              with open('README.md', 'r') as f:
                  readme = f.read()
              if function_name in readme or function_name.replace('-', '_') in readme:
                  doc_files['README.md'] = readme
          except:
              pass

          if not doc_files:
              print(f"No docs reference {function_name}, skipping")
              exit(0)

          print(f"Found {len(doc_files)} related docs: {list(doc_files.keys())}")

          api_key = os.environ.get('ANTHROPIC_API_KEY', '')
          if not api_key:
              print("No Anthropic API key, skipping docs update")
              exit(0)

          # å„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã¤ã„ã¦Claudeã«æ›´æ–°ãŒå¿…è¦ã‹åˆ¤æ–­ã•ã›ã‚‹
          updated_count = 0
          for doc_path, doc_content in doc_files.items():
              prompt = f"""ã‚ãªãŸã¯ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ç®¡ç†è€…ã§ã™ã€‚

          Lambdaé–¢æ•°ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãŒä¿®æ­£ã•ã‚Œã¾ã—ãŸã€‚é–¢é€£ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ä¸æ•´åˆãŒãªã„ã‹ç¢ºèªã—ã€å¿…è¦ãªã‚‰ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚

          ## ä¿®æ­£ã•ã‚ŒãŸLambdaé–¢æ•°: {function_name}

          ## ã‚³ãƒ¼ãƒ‰å¤‰æ›´ã®å·®åˆ†
          ```diff
          {diff_text[:3000]}
          ```

          ## ä¿®æ­£ã®åˆ†æž
          {analysis[:1000]}

          ## ä¿®æ­£å¾Œã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ï¼ˆå‚è€ƒï¼‰
          ```python
          {fixed_code[:4000]}
          ```

          ## å¯¾è±¡ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: {doc_path}
          ```markdown
          {doc_content}
          ```

          ## æŒ‡ç¤º
          - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®å†…å®¹ãŒã‚³ãƒ¼ãƒ‰å¤‰æ›´ã¨çŸ›ç›¾ã—ã¦ã„ãªã„ã‹ç¢ºèª
          - çŸ›ç›¾ã‚„ä¸æ•´åˆãŒã‚ã‚‹ç®‡æ‰€ã ã‘ã‚’ä¿®æ­£ã—ã€ãã‚Œä»¥å¤–ã¯å¤‰æ›´ã—ãªã„
          - ä¿®æ­£ãŒä¸è¦ãªå ´åˆã¯ã€ŒNO_UPDATE_NEEDEDã€ã¨ã ã‘å‡ºåŠ›ã™ã‚‹
          - ä¿®æ­£ãŒå¿…è¦ãªå ´åˆã¯ã€ä¿®æ­£å¾Œã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå…¨ä½“ã‚’ä»¥ä¸‹ã®ãƒžãƒ¼ã‚«ãƒ¼ã§å›²ã‚“ã§å‡ºåŠ›ã™ã‚‹

          ---DOC_START---
          ï¼ˆä¿®æ­£å¾Œã®Markdownãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå…¨ä½“ï¼‰
          ---DOC_END---
          """

              request_body = {
                  "model": "claude-sonnet-4-20250514",
                  "max_tokens": 8192,
                  "messages": [{"role": "user", "content": prompt}]
              }
              headers = {
                  "x-api-key": api_key,
                  "anthropic-version": "2023-06-01",
                  "content-type": "application/json"
              }

              try:
                  req = urllib.request.Request(
                      "https://api.anthropic.com/v1/messages",
                      data=json.dumps(request_body).encode('utf-8'),
                      headers=headers,
                      method='POST'
                  )
                  response = urllib.request.urlopen(req, timeout=120)
                  result = json.loads(response.read().decode('utf-8'))
                  content = result['content'][0]['text']

                  if 'NO_UPDATE_NEEDED' in content:
                      print(f"  {doc_path}: No update needed")
                  elif '---DOC_START---' in content and '---DOC_END---' in content:
                      updated_doc = content.split('---DOC_START---')[1].split('---DOC_END---')[0].strip()
                      # Markdownã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãƒžãƒ¼ã‚«ãƒ¼ã‚’é™¤åŽ»
                      if updated_doc.startswith('```markdown'):
                          updated_doc = updated_doc[len('```markdown'):].strip()
                      if updated_doc.startswith('```'):
                          updated_doc = updated_doc[3:].strip()
                      if updated_doc.endswith('```'):
                          updated_doc = updated_doc[:-3].strip()

                      with open(doc_path, 'w') as f:
                          f.write(updated_doc + '\n')
                      print(f"  {doc_path}: Updated âœ…")
                      updated_count += 1
                  else:
                      print(f"  {doc_path}: Could not parse response, skipping")

              except Exception as e:
                  print(f"  {doc_path}: Claude API error: {e}")

          print(f"\nDocs update complete: {updated_count} files updated")
          DOCS_SCRIPT

      - name: Push all changes
        if: success() && steps.verify.outputs.verify_status == 'success'
        run: |
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"

          # åˆ†æžã‚³ãƒ¡ãƒ³ãƒˆèª­ã¿è¾¼ã¿
          ANALYSIS=$(cat /tmp/analysis.txt 2>/dev/null | head -5 || echo "Auto-fix applied")

          git add -A
          git diff --cached --quiet && echo "No changes to commit" && exit 0
          git commit -m "fix(${FUNCTION_NAME}): auto-fix error + docs update [bot]" \
            -m "${ANALYSIS}"
          git push
