name: Auto-Fix Lambda Errors

on:
  repository_dispatch:
    types: [lambda-error]

permissions:
  contents: write
  models: read

env:
  AWS_REGION: ap-northeast-1

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_AUTO_FIX_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Extract error context
        id: error
        run: |
          cat << 'PAYLOAD_EOF' > /tmp/error_payload.json
          ${{ toJson(github.event.client_payload) }}
          PAYLOAD_EOF

          FUNCTION_NAME=$(jq -r '.function_name' /tmp/error_payload.json)
          ERROR_SUMMARY=$(jq -r '.error_summary' /tmp/error_payload.json)
          SERVICE_DIR=$(jq -r '.service_dir' /tmp/error_payload.json)
          LOG_GROUP=$(jq -r '.log_group' /tmp/error_payload.json)

          echo "function_name=${FUNCTION_NAME}" >> $GITHUB_OUTPUT
          echo "service_dir=${SERVICE_DIR}" >> $GITHUB_OUTPUT
          echo "log_group=${LOG_GROUP}" >> $GITHUB_OUTPUT

          # ã‚¨ãƒ©ãƒ¼ã‚µãƒãƒªãƒ¼ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ï¼ˆæ”¹è¡Œä¿æŒï¼‰
          echo "${ERROR_SUMMARY}" > /tmp/error_summary.txt

          echo "=== Error Context ==="
          echo "Function: ${FUNCTION_NAME}"
          echo "Service dir: ${SERVICE_DIR}"
          head -20 /tmp/error_summary.txt

      - name: Fetch extended error logs from CloudWatch
        id: logs
        run: |
          # ç›´è¿‘30åˆ†ã®ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’å–å¾—
          START_TIME=$(( $(date +%s) * 1000 - 1800000 ))
          LOG_GROUP="${{ steps.error.outputs.log_group }}"

          aws logs filter-log-events \
            --log-group-name "${LOG_GROUP}" \
            --start-time ${START_TIME} \
            --filter-pattern "?ERROR ?Traceback ?Exception" \
            --limit 50 \
            --query "events[*].message" \
            --output text > /tmp/cloudwatch_errors.txt 2>/dev/null || true

          echo "=== CloudWatch Error Logs ==="
          head -50 /tmp/cloudwatch_errors.txt

      - name: Read source code
        id: source
        run: |
          SERVICE_DIR="${{ steps.error.outputs.service_dir }}"
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"

          if [ -f "${SERVICE_DIR}" ]; then
            echo "Reading: ${SERVICE_DIR}"
            cp "${SERVICE_DIR}" /tmp/original_source.py
          else
            echo "Service file not found: ${SERVICE_DIR}"
            echo "Searching for handler..."
            FOUND=$(find services/ -path "*${FUNCTION_NAME}*" -name "handler.py" | head -1)
            if [ -n "${FOUND}" ]; then
              echo "Found: ${FOUND}"
              echo "service_dir=${FOUND}" >> $GITHUB_OUTPUT
              cp "${FOUND}" /tmp/original_source.py
            else
              echo "No handler found for ${FUNCTION_NAME}"
              exit 1
            fi
          fi

          echo "=== Source Code (first 30 lines) ==="
          head -30 /tmp/original_source.py

      - name: Analyze and fix with Claude
        id: claude
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'CLAUDE_SCRIPT'
          import json
          import os
          import urllib.request

          function_name = "${{ steps.error.outputs.function_name }}"
          service_dir = "${{ steps.error.outputs.service_dir }}"

          # ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿
          with open('/tmp/original_source.py', 'r') as f:
              source_code = f.read()

          # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸èª­ã¿è¾¼ã¿
          with open('/tmp/error_summary.txt', 'r') as f:
              error_summary = f.read()

          # CloudWatchãƒ­ã‚°èª­ã¿è¾¼ã¿
          cw_logs = ""
          try:
              with open('/tmp/cloudwatch_errors.txt', 'r') as f:
                  cw_logs = f.read()[:3000]
          except:
              pass

          # GitHub Models API çµŒç”±ã§ Claude ã‚’ä½¿ç”¨ï¼ˆç„¡æ–™ï¼‰
          token = os.environ.get('GITHUB_TOKEN', '')
          api_url = "https://models.inference.ai.azure.com/chat/completions"
          headers = {
              "Authorization": f"Bearer {token}",
              "Content-Type": "application/json"
          }
          model = "claude-sonnet-4-20250514"

          prompt = f"""ã‚ãªãŸã¯AWS Lambdaã®ã‚¨ãƒ©ãƒ¼ã‚’è‡ªå‹•ä¿®å¾©ã™ã‚‹ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã™ã€‚

          ä»¥ä¸‹ã®Lambdaé–¢æ•°ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼ã‚’åˆ†æã—ã€ä¿®æ­£ã—ãŸã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚

          ## ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸLambdaé–¢æ•°
          - é–¢æ•°å: eth-trading-{function_name}
          - ãƒ•ã‚¡ã‚¤ãƒ«: {service_dir}

          ## ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°
          ```
          {error_summary[:2000]}
          ```

          ## CloudWatchè©³ç´°ãƒ­ã‚°
          ```
          {cw_logs[:2000]}
          ```

          ## ç¾åœ¨ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰
          ```python
          {source_code}
          ```

          ## æŒ‡ç¤º
          1. ã‚¨ãƒ©ãƒ¼ã®æ ¹æœ¬åŸå› ã‚’åˆ†æã—ã¦ãã ã•ã„
          2. ä¿®æ­£ã—ãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„
          3. ä½•ã‚’ä¿®æ­£ã—ãŸã‹ç°¡æ½”ã«èª¬æ˜ã—ã¦ãã ã•ã„

          ## å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆå³å¯†ã«å¾“ã£ã¦ãã ã•ã„ï¼‰
          ã¾ãšåˆ†æã¨ä¿®æ­£å†…å®¹ã®èª¬æ˜ã‚’æ›¸ãã€æ¬¡ã«ä¿®æ­£å¾Œã®ã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’ä»¥ä¸‹ã®ãƒãƒ¼ã‚«ãƒ¼ã§å›²ã‚“ã§å‡ºåŠ›ã—ã¦ãã ã•ã„:

          ---ANALYSIS_START---
          ï¼ˆåˆ†æã¨ä¿®æ­£å†…å®¹ã®èª¬æ˜ï¼‰
          ---ANALYSIS_END---

          ---CODE_START---
          ï¼ˆä¿®æ­£å¾Œã®Pythonã‚³ãƒ¼ãƒ‰å…¨ä½“ï¼‰
          ---CODE_END---

          æ³¨æ„:
          - ã‚³ãƒ¼ãƒ‰ã¯å®Œå…¨ãªãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’å‡ºåŠ›ã™ã‚‹ã“ã¨ï¼ˆå·®åˆ†ã§ã¯ãªãï¼‰
          - ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æ­£ç¢ºã«ä¿ã¤ã“ã¨
          - importæ–‡ã‚’å¿˜ã‚Œãªã„ã“ã¨
          - ç’°å¢ƒå¤‰æ•°ã‚„AWSãƒªã‚½ãƒ¼ã‚¹åã¯å¤‰æ›´ã—ãªã„ã“ã¨
          - ã‚¨ãƒ©ãƒ¼ã«ç„¡é–¢ä¿‚ãªå¤‰æ›´ã¯åŠ ãˆãªã„ã“ã¨
          """

          # GitHub Models API (OpenAIäº’æ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ)
          request_body = {
              "model": model,
              "max_tokens": 8192,
              "messages": [
                  {"role": "system", "content": "You are an expert AWS Lambda error fixer."},
                  {"role": "user", "content": prompt}
              ]
          }

          req = urllib.request.Request(
              api_url,
              data=json.dumps(request_body).encode('utf-8'),
              headers=headers,
              method='POST'
          )

          try:
              response = urllib.request.urlopen(req, timeout=120)
              result = json.loads(response.read().decode('utf-8'))

              content = result['choices'][0]['message']['content']

              print("=== Claude Response (first 500 chars) ===")
              print(content[:500])

              # åˆ†æéƒ¨åˆ†ã‚’æŠ½å‡º
              analysis = ""
              if '---ANALYSIS_START---' in content and '---ANALYSIS_END---' in content:
                  analysis = content.split('---ANALYSIS_START---')[1].split('---ANALYSIS_END---')[0].strip()

              # ã‚³ãƒ¼ãƒ‰éƒ¨åˆ†ã‚’æŠ½å‡º
              if '---CODE_START---' in content and '---CODE_END---' in content:
                  fixed_code = content.split('---CODE_START---')[1].split('---CODE_END---')[0].strip()

                  # Pythonã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’é™¤å»
                  if fixed_code.startswith('```python'):
                      fixed_code = fixed_code[len('```python'):].strip()
                  if fixed_code.startswith('```'):
                      fixed_code = fixed_code[3:].strip()
                  if fixed_code.endswith('```'):
                      fixed_code = fixed_code[:-3].strip()

                  with open('/tmp/fixed_source.py', 'w') as f:
                      f.write(fixed_code + '\n')

                  with open('/tmp/analysis.txt', 'w') as f:
                      f.write(analysis)

                  print("\n=== Analysis ===")
                  print(analysis[:500])
                  print("\n=== Fixed code written successfully ===")

                  # å·®åˆ†ç”Ÿæˆ
                  import subprocess
                  diff_result = subprocess.run(
                      ['diff', '-u', '/tmp/original_source.py', '/tmp/fixed_source.py'],
                      capture_output=True, text=True
                  )
                  with open('/tmp/diff.txt', 'w') as f:
                      f.write(diff_result.stdout)

                  print("\n=== Diff ===")
                  print(diff_result.stdout[:1000])

              else:
                  print("ERROR: Could not extract fixed code from Claude response")
                  print("Full response:")
                  print(content)
                  with open('/tmp/analysis.txt', 'w') as f:
                      f.write(f"ã‚³ãƒ¼ãƒ‰æŠ½å‡ºå¤±æ•—ã€‚Claudeå¿œç­”:\n{content[:2000]}")
                  exit(1)

          except Exception as e:
              print(f"Claude API call failed: {e}")
              with open('/tmp/analysis.txt', 'w') as f:
                  f.write(f"Claude APIå‘¼ã³å‡ºã—å¤±æ•—: {str(e)}")
              exit(1)

          CLAUDE_SCRIPT

      - name: Validate fixed code (syntax check)
        id: validate
        run: |
          echo "=== Syntax Check ==="
          python3 -c "
          import py_compile
          try:
              py_compile.compile('/tmp/fixed_source.py', doraise=True)
              print('Syntax OK')
          except py_compile.PyCompileError as e:
              print(f'Syntax Error: {e}')
              exit(1)
          "

      - name: Apply fix
        run: |
          SERVICE_DIR="${{ steps.error.outputs.service_dir }}"
          cp /tmp/fixed_source.py "${SERVICE_DIR}"
          echo "Fixed code applied to ${SERVICE_DIR}"

      - name: Deploy to AWS Lambda
        id: deploy
        run: |
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"
          LAMBDA_NAME="eth-trading-${FUNCTION_NAME}"
          SERVICE_DIR="services/${FUNCTION_NAME}"

          echo "Packaging ${SERVICE_DIR}..."
          cd "${SERVICE_DIR}"
          zip -r /tmp/lambda_deploy.zip .
          cd -

          echo "Deploying to ${LAMBDA_NAME}..."
          aws lambda update-function-code \
            --function-name "${LAMBDA_NAME}" \
            --zip-file fileb:///tmp/lambda_deploy.zip \
            --output json > /tmp/deploy_result.json

          echo "Deploy complete"
          jq '.LastModified, .CodeSha256' /tmp/deploy_result.json

      - name: Verify deployment
        id: verify
        run: |
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"
          LAMBDA_NAME="eth-trading-${FUNCTION_NAME}"

          echo "Waiting 10 seconds for deployment to stabilize..."
          sleep 10

          # Lambdaé–¢æ•°ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
          STATE=$(aws lambda get-function-configuration \
            --function-name "${LAMBDA_NAME}" \
            --query "State" --output text)
          echo "Lambda state: ${STATE}"

          if [ "${STATE}" != "Active" ]; then
            echo "Lambda is not Active, waiting..."
            aws lambda wait function-active --function-name "${LAMBDA_NAME}"
          fi

          # ç›´è¿‘ã®ã‚¨ãƒ©ãƒ¼ã‚’ç¢ºèªï¼ˆãƒ‡ãƒ—ãƒ­ã‚¤å¾Œ2åˆ†ä»¥å†…ï¼‰
          sleep 30
          DEPLOY_TIME=$(( $(date +%s) * 1000 - 30000 ))
          LOG_GROUP="/aws/lambda/${LAMBDA_NAME}"

          ERRORS=$(aws logs filter-log-events \
            --log-group-name "${LOG_GROUP}" \
            --start-time ${DEPLOY_TIME} \
            --filter-pattern "?ERROR ?Traceback ?Exception" \
            --query "events[*].message" \
            --output text 2>/dev/null || echo "")

          if [ -n "${ERRORS}" ] && [ "${ERRORS}" != "None" ]; then
            echo "âš ï¸ Post-deploy errors detected:"
            echo "${ERRORS}" | head -10
            echo "verify_status=warning" >> $GITHUB_OUTPUT
          else
            echo "âœ… No errors detected after deployment"
            echo "verify_status=success" >> $GITHUB_OUTPUT
          fi

      - name: Notify Slack (result)
        if: always()
        run: |
          python3 << 'SLACK_SCRIPT'
          import json
          import urllib.request
          import os

          webhook_url = "${{ secrets.SLACK_WEBHOOK_URL }}"
          if not webhook_url:
              print("No Slack webhook URL")
              exit(0)

          function_name = "${{ steps.error.outputs.function_name }}"
          verify_status = "${{ steps.verify.outputs.verify_status }}"
          job_status = "${{ job.status }}"

          # åˆ†æçµæœèª­ã¿è¾¼ã¿
          analysis = "ï¼ˆåˆ†ææƒ…å ±ãªã—ï¼‰"
          try:
              with open('/tmp/analysis.txt', 'r') as f:
                  analysis = f.read()[:1000]
          except:
              pass

          # å·®åˆ†èª­ã¿è¾¼ã¿
          diff_text = "ï¼ˆå·®åˆ†ãªã—ï¼‰"
          try:
              with open('/tmp/diff.txt', 'r') as f:
                  diff_text = f.read()[:1500]
          except:
              pass

          if job_status == "success" and verify_status == "success":
              emoji = "âœ…"
              status_text = "è‡ªå‹•ä¿®å¾©æˆåŠŸ"
              color = "#36a64f"
          elif job_status == "success" and verify_status == "warning":
              emoji = "âš ï¸"
              status_text = "ä¿®å¾©æ¸ˆã¿ï¼ˆãƒ‡ãƒ—ãƒ­ã‚¤å¾Œã«ã‚¨ãƒ©ãƒ¼æ¤œå‡ºã‚ã‚Šï¼‰"
              color = "#ff9900"
          else:
              emoji = "âŒ"
              status_text = "è‡ªå‹•ä¿®å¾©å¤±æ•— - æ‰‹å‹•å¯¾å¿œãŒå¿…è¦"
              color = "#ff0000"

          payload = {
              "blocks": [
                  {
                      "type": "header",
                      "text": {
                          "type": "plain_text",
                          "text": f"{emoji} Auto-Fix: {function_name}"
                      }
                  },
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"*ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:* {status_text}\n*é–¢æ•°:* `eth-trading-{function_name}`"
                      }
                  },
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"*ğŸ” åˆ†æ:*\n{analysis[:800]}"
                      }
                  },
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"*ğŸ“ å¤‰æ›´å·®åˆ†:*\n```{diff_text[:1200]}```"
                      }
                  }
              ]
          }

          req = urllib.request.Request(
              webhook_url,
              data=json.dumps(payload).encode('utf-8'),
              headers={'Content-Type': 'application/json'}
          )
          try:
              response = urllib.request.urlopen(req, timeout=10)
              print(f"Slack notification sent: {response.status}")
          except Exception as e:
              print(f"Slack notification failed: {e}")

          SLACK_SCRIPT

      - name: Commit and push fix
        if: success() && steps.verify.outputs.verify_status == 'success'
        run: |
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"

          # åˆ†æã‚³ãƒ¡ãƒ³ãƒˆèª­ã¿è¾¼ã¿
          ANALYSIS=$(cat /tmp/analysis.txt 2>/dev/null | head -5 || echo "Auto-fix applied")

          git config user.name "auto-fix-bot"
          git config user.email "auto-fix-bot@users.noreply.github.com"
          git add -A
          git diff --cached --quiet && echo "No changes to commit" && exit 0
          git commit -m "fix(${FUNCTION_NAME}): auto-fix error [bot]" \
            -m "${ANALYSIS}"
          git push

      - name: Update docs if needed
        if: success() && steps.verify.outputs.verify_status == 'success'
        run: |
          FUNCTION_NAME="${{ steps.error.outputs.function_name }}"
          SERVICE_DIR="${{ steps.error.outputs.service_dir }}"

          # å¤‰æ›´ãŒå¤§ãã„å ´åˆã®ã¿ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ãƒã‚§ãƒƒã‚¯
          DIFF_LINES=$(wc -l < /tmp/diff.txt 2>/dev/null || echo "0")

          if [ "${DIFF_LINES}" -gt 20 ]; then
            echo "Large change detected (${DIFF_LINES} lines). Checking docs..."

            # docs/ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¢ºèª
            RELATED_DOCS=$(grep -rl "${FUNCTION_NAME}" docs/ 2>/dev/null || echo "")
            if [ -n "${RELATED_DOCS}" ]; then
              echo "Related docs found: ${RELATED_DOCS}"
              echo "ğŸ“ TODO: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æ›´æ–°ãŒå¿…è¦ãªå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™"
              # ã“ã“ã«Claude APIã§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ å¯èƒ½
            fi
          fi
