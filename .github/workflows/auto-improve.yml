name: Auto-Improve Trading Algorithm

on:
  repository_dispatch:
    types: [daily-improvement]

permissions:
  contents: write
  models: read

env:
  AWS_REGION: ap-northeast-1

jobs:
  auto-improve:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_AUTO_FIX_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Extract report
        id: report
        run: |
          cat << 'PAYLOAD_EOF' > /tmp/daily_report.json
          ${{ toJson(github.event.client_payload.report) }}
          PAYLOAD_EOF

          REPORT_DATE=$(jq -r '.date' /tmp/daily_report.json)
          TRADES_COUNT=$(jq -r '.trades.total' /tmp/daily_report.json)
          WIN_RATE=$(jq -r '.trades.win_rate' /tmp/daily_report.json)
          PNL=$(jq -r '.trades.total_pnl_jpy' /tmp/daily_report.json)

          echo "report_date=${REPORT_DATE}" >> $GITHUB_OUTPUT
          echo "=== Daily Report: ${REPORT_DATE} ==="
          echo "Trades: ${TRADES_COUNT}, Win Rate: ${WIN_RATE}, PnL: ¬•${PNL}"

      - name: Pre-check data quality gate
        id: precheck
        run: |
          # === „Ç≥„Éº„Éâ„É¨„Éô„É´„ÅÆÂº∑Âà∂„Ç≤„Éº„Éà (Claude„Éó„É≠„É≥„Éó„Éà‰ªª„Åõ„Å´„Åó„Å™„ÅÑ) ===
          echo "=== Pre-Check: Data Quality Gate ==="

          # data_quality „Éï„Ç£„Éº„É´„Éâ„ÇíÁ¢∫Ë™ç
          ALLOW=$(jq -r '.data_quality.allow_improvement // true' /tmp/daily_report.json)
          CONFIDENCE=$(jq -r '.data_quality.confidence_score // 0' /tmp/daily_report.json)
          SKIP_REASONS=$(jq -r '.data_quality.skip_reasons // [] | join(", ")' /tmp/daily_report.json)
          TRADES_7D=$(jq -r '.data_quality.trades_7d_paired // 0' /tmp/daily_report.json)
          CI_WIDTH=$(jq -r '.data_quality.win_rate_7d_ci.width // 1.0' /tmp/daily_report.json)
          DAYS_SINCE=$(jq -r '.data_quality.days_since_last_change // "none"' /tmp/daily_report.json)

          echo "allow_improvement: ${ALLOW}"
          echo "confidence_score: ${CONFIDENCE}"
          echo "trades_7d: ${TRADES_7D}"
          echo "ci_width: ${CI_WIDTH}"
          echo "days_since_last_change: ${DAYS_SINCE}"
          echo "skip_reasons: ${SKIP_REASONS}"

          # === „Éè„Éº„Éâ„Ç≥„Éº„Éâ2Ê¨°„ÉÅ„Çß„ÉÉ„ÇØ (daily-reporterÈÄöÈÅéÂæå„ÅÆ‰∫åÈáçÈò≤Âæ°) ===
          HARD_SKIP="false"

          # 7Êó•Èñì„ÅÆ„Éà„É¨„Éº„ÉâÊï∞„Åå5Êú™Ê∫Ä ‚Üí Âº∑Âà∂„Çπ„Ç≠„ÉÉ„Éó
          if [ "$(echo "${TRADES_7D} < 5" | bc)" = "1" ]; then
            echo "HARD SKIP: trades_7d=${TRADES_7D} < 5"
            HARD_SKIP="true"
          fi

          # Áõ¥ËøëÂ§âÊõ¥„Åã„Çâ7Êó•Êú™Ê∫Ä ‚Üí Âº∑Âà∂„Çπ„Ç≠„ÉÉ„Éó (ÂäπÊûúÊ∏¨ÂÆö‰∏≠)
          if [ "${DAYS_SINCE}" != "none" ] && [ "${DAYS_SINCE}" != "null" ]; then
            if [ "$(echo "${DAYS_SINCE} < 7" | bc)" = "1" ]; then
              echo "HARD SKIP: days_since_last_change=${DAYS_SINCE} < 7"
              HARD_SKIP="true"
            fi
          fi

          # data_quality.allow_improvement == false ‚Üí Âº∑Âà∂„Çπ„Ç≠„ÉÉ„Éó
          if [ "${ALLOW}" = "false" ]; then
            echo "HARD SKIP: data_quality.allow_improvement=false (${SKIP_REASONS})"
            HARD_SKIP="true"
          fi

          echo "hard_skip=${HARD_SKIP}" >> $GITHUB_OUTPUT
          echo "confidence=${CONFIDENCE}" >> $GITHUB_OUTPUT
          echo "skip_reasons=${SKIP_REASONS}" >> $GITHUB_OUTPUT

          if [ "${HARD_SKIP}" = "true" ]; then
            echo "‚ùå Data quality gate FAILED ‚Äî skipping Claude analysis"
            # NO_ACTION decision „ÇíÁõ¥Êé•Êõ∏„ÅçÂá∫„Åó (Claude APIÂëº„Å≥Âá∫„Åó„ÇíÂÆåÂÖ®„Å´„Çπ„Ç≠„ÉÉ„Éó)
            cat > /tmp/decision.json << EOF
          {
            "decision": "NO_ACTION",
            "confidence": 0,
            "reasoning": "„Éá„Éº„ÇøÂìÅË≥™„Ç≤„Éº„Éà‰∏çÈÄöÈÅé: ${SKIP_REASONS:-insufficient data}",
            "statistical_evidence": {"key_metric": "data_quality_gate", "value": "${TRADES_7D} trades / CI ${CI_WIDTH}", "threshold": "5 trades / CI < 0.40"},
            "proposed_changes": [],
            "doc_updates_needed": false,
            "lambdas_to_deploy": [],
            "commit_message": "",
            "slack_summary": "„Éá„Éº„Çø‰∏çË∂≥„ÅÆ„Åü„ÇÅÂàÜÊûê„Çπ„Ç≠„ÉÉ„Éó (7d trades=${TRADES_7D})",
            "rollback_criteria": "N/A",
            "improvement_record": {"summary": "NO_ACTION: data quality gate", "changes_applied": []}
          }
          EOF
          else
            echo "‚úÖ Data quality gate PASSED ‚Äî proceeding to Claude analysis"
          fi

      - name: Read source code for analysis
        if: steps.precheck.outputs.hard_skip != 'true'
        run: |
          # ÂàÜÊûê„Å´ÂøÖË¶Å„Å™„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÇíÂèéÈõÜ
          echo "=== Collecting source files ==="

          # aggregator (ÈñæÂÄ§„Éª„Ç¶„Çß„Ç§„Éà)
          cat services/aggregator/handler.py > /tmp/aggregator.py
          echo "aggregator.py: $(wc -l < services/aggregator/handler.py) lines"

          # technical („ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ô)
          cat services/technical/handler.py > /tmp/technical.py
          echo "technical.py: $(wc -l < services/technical/handler.py) lines"

          # chronos-caller (AI‰∫àÊ∏¨)
          cat services/chronos-caller/handler.py > /tmp/chronos.py
          echo "chronos.py: $(wc -l < services/chronos-caller/handler.py) lines"

          # news-collector („Çª„É≥„ÉÅ„É°„É≥„Éà)
          cat services/news-collector/handler.py > /tmp/news.py
          echo "news.py: $(wc -l < services/news-collector/handler.py) lines"

          # market-context
          cat services/market-context/handler.py > /tmp/market_ctx.py
          echo "market_ctx.py: $(wc -l < services/market-context/handler.py) lines"

          # position-monitor (SL/TP)
          cat services/position-monitor/handler.py > /tmp/position.py
          echo "position.py: $(wc -l < services/position-monitor/handler.py) lines"

          # order-executor (Ê≥®Êñá„Éª„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„Éº)
          cat services/order-executor/handler.py > /tmp/order.py
          echo "order.py: $(wc -l < services/order-executor/handler.py) lines"

          # „Éâ„Ç≠„É•„É°„É≥„Éà
          for doc in docs/*.md; do
            cp "$doc" /tmp/doc_$(basename "$doc")
          done
          echo "Docs copied: $(ls /tmp/doc_*.md | wc -l) files"

      - name: Analyze with Claude and decide
        id: claude
        if: steps.precheck.outputs.hard_skip != 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python3 << 'CLAUDE_SCRIPT'
          import json
          import os
          import urllib.request
          import glob

          # === „É¨„Éù„Éº„ÉàË™≠„ÅøËæº„Åø ===
          with open('/tmp/daily_report.json', 'r') as f:
              report = json.load(f)

          # === „ÇΩ„Éº„Çπ„Ç≥„Éº„ÉâË™≠„ÅøËæº„ÅøÔºà‰∏ªË¶ÅÈÉ®ÂàÜ„ÅÆ„ÅøÔºâ ===
          source_files = {}
          for name in ['aggregator', 'technical', 'chronos', 'news', 'market_ctx',
                       'position', 'order']:
              path = f'/tmp/{name}.py'
              if os.path.exists(path):
                  with open(path, 'r') as f:
                      content = f.read()
                  # 4000ÊñáÂ≠ó„Å´Âà∂ÈôêÔºàClaude „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÁØÄÁ¥ÑÔºâ
                  source_files[name] = content[:8000]

          # === „Éâ„Ç≠„É•„É°„É≥„ÉàË™≠„ÅøËæº„Åø ===
          doc_files = {}
          for path in sorted(glob.glob('/tmp/doc_*.md')):
              name = os.path.basename(path).replace('doc_', '')
              with open(path, 'r') as f:
                  doc_files[name] = f.read()[:3000]

          # === „Éó„É≠„É≥„Éó„ÉàÊßãÁØâ ===
          report_json = json.dumps(report, indent=2, ensure_ascii=False)

          source_summary = ""
          for name, code in source_files.items():
              source_summary += f"\n### {name}.py\n```python\n{code}\n```\n"

          prompt = f"""„ÅÇ„Å™„Åü„ÅØÊöóÂè∑ÈÄöË≤®„Éà„É¨„Éº„Éá„Ç£„É≥„Ç∞„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÂàÜÊûêÂÆòÂÖº„Ç®„É≥„Ç∏„Éã„Ç¢„Åß„Åô„ÄÇ
Êó•Ê¨°„É¨„Éù„Éº„Éà„ÇíÂàÜÊûê„Åó„ÄÅ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÊîπÂñÑ„ÅåÂøÖË¶Å„Åã„Å©„ÅÜ„Åã„ÇíÂà§Êñ≠„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

## Êó•Ê¨°„É¨„Éù„Éº„Éà
```json
{report_json}
```

## ÁèæÂú®„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„ÉâÔºà‰∏ªË¶Å„Éï„Ç°„Ç§„É´Ôºâ
{source_summary}

## „Éá„Éº„ÇøÂìÅË≥™ÊÉÖÂ†±
„É¨„Éù„Éº„Éà„ÅÆ `data_quality` „Éï„Ç£„Éº„É´„Éâ„Å´Áµ±Ë®àÁöÑ‰ø°È†ºÊÄß„ÅÆÊÉÖÂ†±„Åå„ÅÇ„Çä„Åæ„Åô:
- `allow_improvement`: ÂÖ®„Ç≤„Éº„ÉàÈÄöÈÅéÊôÇ„ÅÆ„Åø trueÔºàfalse „Å™„ÇâÂøÖ„Åö NO_ACTIONÔºâ
- `confidence_score`: 0.0-1.0 „ÅÆ„Éá„Éº„Çø‰ø°È†ºÂ∫¶
- `win_rate_7d_ci`: ÂãùÁéá„ÅÆ95% Wilson‰ø°È†ºÂå∫Èñì (lower, upper, width)
- `skip_reasons`: „Ç≤„Éº„Éà‰∏çÈÄöÈÅé„ÅÆÁêÜÁî±„É™„Çπ„Éà

„Åì„ÅÆÊÉÖÂ†±„ÇíÂèÇËÄÉ„Å´„ÄÅconfidence_score „Åå 0.5 Êú™Ê∫Ä„ÅÆÂ†¥Âêà„ÅØ NO_ACTION „ÇíÂº∑„ÅèÊé®Â•®„ÄÇ
‰ø°È†ºÂå∫Èñì„ÅåÂ∫É„ÅÑ (width > 0.30) Â†¥Âêà„ÄÅÂãùÁéá„ÅÆËâØ„ÅóÊÇ™„Åó„ÅÆÂà§Êñ≠„ÅØÁµ±Ë®àÁöÑ„Å´‰∏çÁ¢∫ÂÆü„Åß„Åô„ÄÇ

## Âà§Êñ≠Âü∫Ê∫ñ

### NO_ACTIONÔºàÂ§âÊõ¥‰∏çË¶ÅÔºâ„ÅÆÊù°‰ª∂:
- `data_quality.allow_improvement` „Åå falseÔºà„Éá„Éº„ÇøÂìÅË≥™„Ç≤„Éº„Éà‰∏çÈÄöÈÅéÔºâ
- `data_quality.confidence_score` „Åå 0.5 Êú™Ê∫ÄÔºà‰ø°È†ºÊÄß„Åå‰Ωé„ÅÑÔºâ
- Â∏ÇÂ†¥ÂÖ®‰Ωì„Åå‰∏ÄÊñπÂêë„Å´Âãï„ÅÑ„ÅüÊó•ÔºàÂÖ®ÈÄöË≤®‰∏ãËêΩÊôÇ„Å´ÊêçÂ§±„ÅØÊ≠£Â∏∏„ÄÅ`all_same_direction` ÂèÇÁÖßÔºâ
- Êó•Ê¨°„Éà„É¨„Éº„Éâ3‰ª∂Êú™Ê∫ÄÔºàÁµ±Ë®àÁöÑ„Å´ÁÑ°ÊÑèÂë≥Ôºâ
- 7Êó•„É≠„Éº„É™„É≥„Ç∞ÂãùÁéá„ÅÆ‰ø°È†ºÂå∫Èñì„ÅåÂ∫É„ÅÑÔºàwidth > 0.30Ôºâ„Åß„ÄÅÂãùÁéá„Åå25-55%„ÅÆÁØÑÂõ≤ÂÜÖ
- ÂÄãÂà•ÊêçÂ§±„ÅÆÂéüÂõ†„ÅåÂ∏ÇÂ†¥ÊÄ•Â§âÔºàF&GÊÄ•Â§âÂãï„ÄÅÁ™ÅÁô∫„Éã„É•„Éº„ÇπÔºâ
- Áõ¥Ëøë7Êó•‰ª•ÂÜÖ„Å´ÊîπÂñÑ„ÅåÈÅ©Áî®„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅÂäπÊûúÊ∏¨ÂÆö„ÅÆ„Åü„ÇÅÂ§âÊõ¥„ÇíÊéß„Åà„Çã

### PARAM_TUNEÔºà„Éë„É©„É°„Éº„ÇøÂæÆË™øÊï¥Ôºâ„ÅÆÊù°‰ª∂:
- `data_quality.confidence_score` >= 0.5 „Åß„ÅÇ„Çã„Åì„Å®ÔºàÂøÖÈ†àÊù°‰ª∂Ôºâ
- ÁâπÂÆö„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆnear_zeroÁéá„Åå60%Ë∂ÖÔºà„Ç¶„Çß„Ç§„ÉàÂâäÊ∏õÂÄôË£úÔºâ
- ÈñæÂÄ§ËøëËæ∫ (¬±0.02) „ÅÆ„Éà„É¨„Éº„Éâ„ÅåÁ≥ªÁµ±ÁöÑ„Å´Ë≤†„Åë„Çã
- 7Êó•„É≠„Éº„É™„É≥„Ç∞ÂãùÁéá„ÅÆ‰ø°È†ºÂå∫Èñì‰∏äÈôê„Åå40%Êú™Ê∫Ä„ÄÅ„Åã„Å§10‰ª∂‰ª•‰∏ä„ÅÆ„Çµ„É≥„Éó„É´
- 30Êó•„É≠„Éº„É™„É≥„Ç∞„Åß‰∏ÄË≤´„Åó„Åü„Éë„Çø„Éº„É≥ÔºàÁâπÂÆöÈÄöË≤®„Éö„Ç¢„ÅåÂ∏∏„Å´Ë≤†„Åë„ÇãÁ≠âÔºâ

### CODE_CHANGEÔºà„É≠„Ç∏„ÉÉ„ÇØÂ§âÊõ¥Ôºâ„ÅÆÊù°‰ª∂:
- `data_quality.confidence_score` >= 0.6 „Åß„ÅÇ„Çã„Åì„Å®ÔºàÂøÖÈ†àÊù°‰ª∂Ôºâ
- Âêå‰∏Ä„Éë„Çø„Éº„É≥„ÅÆÊêçÂ§±„Åå3Êó•‰ª•‰∏äÈÄ£Á∂öÔºàrecent_improvements „ÅßÁ¢∫Ë™çÔºâ
- ÁâπÂÆöÊåáÊ®ô„Åå‰∏ÄË≤´„Åó„Å¶ÈÄÜÊñπÂêë„ÇíÁ§∫„ÅôÔºà„É≠„Ç∏„ÉÉ„ÇØ„Éê„Ç∞„ÅÆÁñë„ÅÑÔºâ
- Êñ∞„Åü„Å™Â∏ÇÂ†¥„Éë„Çø„Éº„É≥„Å∏„ÅÆÊú™ÂØæÂøú„ÅåÊòéÁ¢∫

## ÂÆâÂÖ®„É´„Éº„É´ÔºàÂé≥ÂÆàÔºâ:
1. „Ç¶„Çß„Ç§„ÉàÂ§âÊõ¥„ÅØ1Âõû„ÅÇ„Åü„Çä ¬±0.05 „Åæ„Åß„ÄÅ4ÊàêÂàÜ„ÅÆÂêàË®à„ÅåÂøÖ„Åö1.0
2. ÈñæÂÄ§Â§âÊõ¥„ÅØ1Âõû„ÅÇ„Åü„Çä ¬±0.03 „Åæ„Åß
3. VOL_CLAMP_MIN „ÅØ 0.50„Äú1.00 „ÅÆÁØÑÂõ≤
4. Êó¢Â≠ò„ÅÆÂÆâÂÖ®Ê©üÊßãÔºàÊúÄ‰Ωé‰øùÊúâÊôÇÈñì„ÄÅÈÄöË≤®ÂàÜÊï£Âà∂Èôê„ÄÅ„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÔºâ„ÅØÂâäÈô§Á¶ÅÊ≠¢
5. „Éá„Éº„Çø„Åå‰∏çÂçÅÂàÜ„Å™Â†¥Âêà„ÅØÂøÖ„Åö NO_ACTIONÔºà`data_quality.allow_improvement` „Åå false „Å™„ÇâÁµ∂ÂØæ„Å´Â§âÊõ¥„Åó„Å™„ÅÑÔºâ
6. `data_quality.confidence_score` „Åå 0.5 Êú™Ê∫Ä„Å™„Çâ NO_ACTION ‰ª•Â§ñ„ÇíÈÅ∏„Çì„Åß„ÅØ„ÅÑ„Åë„Å™„ÅÑ
7. importÊñá„ÅÆËøΩÂä†„ÉªÂâäÈô§„ÅØÊÖéÈáç„Å´ÔºàLambdaÁí∞Â¢É„Åß„ÅØÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„ÅÆ„Åø‰ΩøÁî®ÂèØËÉΩ„ÄÅboto3, json„ÅØÂèØÔºâ
8. ÈÅéÂéª„ÅÆÊîπÂñÑ„ÅßÂÖ•„Çå„Åü„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂÆâÊòì„Å´Ê∂à„Åï„Å™„ÅÑ
9. ÂãùÁéá„ÅÆ‰ø°È†ºÂå∫Èñì (win_rate_7d_ci) „ÅåÂ∫É„ÅÑÂ†¥Âêà„ÄÅÂãùÁéá„ÅÆÊï∞ÂÄ§„ÇíÊ†πÊã†„Å´„Åó„Å¶„ÅØ„ÅÑ„Åë„Å™„ÅÑ

## Âá∫Âäõ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºàÂé≥ÂØÜ„Å´JSONÂΩ¢Âºè„ÅßÔºâ:

---DECISION_START---
{{
  "decision": "NO_ACTION" | "PARAM_TUNE" | "CODE_CHANGE",
  "confidence": 0.0-1.0,
  "reasoning": "Âà§Êñ≠„ÅÆÊ†πÊã†ÔºàÊó•Êú¨Ë™û„ÄÅ200ÊñáÂ≠ó‰ª•ÂÜÖÔºâ",
  "statistical_evidence": {{
    "key_metric": "Ê†πÊã†„Å®„Å™„Çã‰∏ªË¶ÅÊåáÊ®ô",
    "value": "ÊåáÊ®ô„ÅÆÂÄ§",
    "threshold": "Âà§Êñ≠Âü∫Ê∫ñ„ÅÆÈñæÂÄ§"
  }},
  "proposed_changes": [
    {{
      "file": "services/aggregator/handler.py",
      "description": "Â§âÊõ¥„ÅÆË™¨Êòé",
      "search": "Â§âÊõ¥Ââç„ÅÆ„Ç≥„Éº„ÉâÔºàÊ≠£Á¢∫„Å´‰∏ÄËá¥„Åô„ÇãÈÉ®ÂàÜÔºâ",
      "replace": "Â§âÊõ¥Âæå„ÅÆ„Ç≥„Éº„Éâ"
    }}
  ],
  "doc_updates_needed": true | false,
  "lambdas_to_deploy": ["aggregator"],
  "commit_message": "improve: Â§âÊõ¥„ÅÆË™¨Êòé",
  "slack_summary": "Slack„Å´ÊäïÁ®ø„Åô„ÇãÊîπÂñÑ„Çµ„Éû„É™„ÉºÔºàÊó•Êú¨Ë™û„ÄÅ100ÊñáÂ≠ó‰ª•ÂÜÖÔºâ",
  "rollback_criteria": "3Êó•‰ª•ÂÜÖ„Å´ÂãùÁéá„ÅåX%Êú™Ê∫Ä„Å´‰Ωé‰∏ã„Åó„ÅüÂ†¥Âêà„É≠„Éº„É´„Éê„ÉÉ„ÇØ",
  "improvement_record": {{
    "summary": "ÊîπÂñÑ„ÅÆË¶ÅÁ¥Ñ",
    "changes_applied": ["Â§âÊõ¥1", "Â§âÊõ¥2"]
  }}
}}
---DECISION_END---

NO_ACTION „ÅÆÂ†¥Âêà„ÅØ proposed_changes „ÇíÁ©∫ÈÖçÂàó []„ÄÅlambdas_to_deploy „ÇíÁ©∫ÈÖçÂàó [] „Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
"""

          # === Claude API Âëº„Å≥Âá∫„Åó ===
          api_key = os.environ.get('ANTHROPIC_API_KEY', '')
          if not api_key:
              print("ERROR: No Anthropic API key")
              # NO_ACTION „Çí„Éá„Éï„Ç©„É´„Éà„Å®„Åó„Å¶Êõ∏„ÅçÂá∫„Åó
              decision = {"decision": "NO_ACTION", "confidence": 0, "reasoning": "API key missing"}
              with open('/tmp/decision.json', 'w') as f:
                  json.dump(decision, f)
              exit(0)

          request_body = {
              "model": "claude-sonnet-4-20250514",
              "max_tokens": 8192,
              "messages": [{"role": "user", "content": prompt}]
          }
          headers = {
              "x-api-key": api_key,
              "anthropic-version": "2023-06-01",
              "content-type": "application/json"
          }

          req = urllib.request.Request(
              "https://api.anthropic.com/v1/messages",
              data=json.dumps(request_body).encode('utf-8'),
              headers=headers,
              method='POST'
          )

          try:
              response = urllib.request.urlopen(req, timeout=300)
              result = json.loads(response.read().decode('utf-8'))
              content = result['content'][0]['text']
              print("=== Claude Response ===")
              print(content[:1000])

              # Decision JSON ÊäΩÂá∫
              if '---DECISION_START---' in content and '---DECISION_END---' in content:
                  decision_str = content.split('---DECISION_START---')[1].split('---DECISION_END---')[0].strip()
                  # JSON„Éñ„É≠„ÉÉ„ÇØÂÜÖ„ÅÆ„Ç≥„Éº„Éâ„Éï„Çß„É≥„Çπ„ÇíÈô§Âéª
                  if decision_str.startswith('```json'):
                      decision_str = decision_str[7:]
                  if decision_str.startswith('```'):
                      decision_str = decision_str[3:]
                  if decision_str.endswith('```'):
                      decision_str = decision_str[:-3]
                  decision_str = decision_str.strip()

                  decision = json.loads(decision_str)
                  with open('/tmp/decision.json', 'w') as f:
                      json.dump(decision, f, indent=2, ensure_ascii=False)
                  print(f"\nDecision: {decision['decision']}")
                  print(f"Confidence: {decision.get('confidence', 0)}")
                  print(f"Reasoning: {decision.get('reasoning', '')}")
              else:
                  print("ERROR: Could not extract decision from Claude response")
                  decision = {"decision": "NO_ACTION", "confidence": 0,
                              "reasoning": "ClaudeÂøúÁ≠î„Åã„ÇâDecision„ÇíÊäΩÂá∫„Åß„Åç„Å™„Åã„Å£„Åü"}
                  with open('/tmp/decision.json', 'w') as f:
                      json.dump(decision, f)

          except Exception as e:
              print(f"Claude API error: {e}")
              decision = {"decision": "NO_ACTION", "confidence": 0,
                          "reasoning": f"Claude API error: {str(e)[:200]}"}
              with open('/tmp/decision.json', 'w') as f:
                  json.dump(decision, f)

          CLAUDE_SCRIPT

      - name: Parse decision
        id: decision
        run: |
          DECISION=$(jq -r '.decision' /tmp/decision.json)
          CONFIDENCE=$(jq -r '.confidence' /tmp/decision.json)
          REASONING=$(jq -r '.reasoning' /tmp/decision.json)
          SLACK_SUMMARY=$(jq -r '.slack_summary // "N/A"' /tmp/decision.json)
          COMMIT_MSG=$(jq -r '.commit_message // "improve: auto-improvement"' /tmp/decision.json)
          DEPLOY_COUNT=$(jq '.lambdas_to_deploy | length' /tmp/decision.json)

          echo "decision=${DECISION}" >> $GITHUB_OUTPUT
          echo "confidence=${CONFIDENCE}" >> $GITHUB_OUTPUT
          echo "deploy_count=${DEPLOY_COUNT}" >> $GITHUB_OUTPUT

          echo "=== Decision ==="
          echo "Decision: ${DECISION}"
          echo "Confidence: ${CONFIDENCE}"
          echo "Reasoning: ${REASONING}"
          echo "Lambdas to deploy: ${DEPLOY_COUNT}"

      - name: Apply code changes
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        run: |
          python3 << 'APPLY_SCRIPT'
          import json

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          changes = decision.get('proposed_changes', [])
          if not changes:
              print("No changes to apply")
              exit(0)

          applied = 0
          failed = 0

          for change in changes:
              filepath = change.get('file', '')
              search = change.get('search', '')
              replace = change.get('replace', '')
              description = change.get('description', '')

              if not filepath or not search:
                  print(f"Skipping invalid change: {description}")
                  failed += 1
                  continue

              try:
                  with open(filepath, 'r') as f:
                      content = f.read()

                  if search not in content:
                      print(f"WARNING: Search string not found in {filepath}")
                      print(f"  Search: {search[:100]}...")
                      failed += 1
                      continue

                  # Ê≠£Á¢∫„Å´1ÁÆáÊâÄ„Å†„ÅëÁΩÆÊèõ
                  count = content.count(search)
                  if count != 1:
                      print(f"WARNING: Search string found {count} times in {filepath}, expected 1")
                      failed += 1
                      continue

                  new_content = content.replace(search, replace, 1)
                  with open(filepath, 'w') as f:
                      f.write(new_content)

                  print(f"‚úÖ Applied: {filepath} - {description}")
                  applied += 1

              except Exception as e:
                  print(f"‚ùå Failed: {filepath} - {e}")
                  failed += 1

          print(f"\nApplied: {applied}, Failed: {failed}")

          if applied == 0 and len(changes) > 0:
              print("ERROR: No changes were applied")
              exit(1)

          APPLY_SCRIPT

      - name: Syntax check
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        run: |
          python3 << 'SYNTAX_SCRIPT'
          import json
          import py_compile

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          files = set()
          for change in decision.get('proposed_changes', []):
              f = change.get('file', '')
              if f and f.endswith('.py'):
                  files.add(f)

          all_ok = True
          for filepath in files:
              try:
                  py_compile.compile(filepath, doraise=True)
                  print(f"‚úÖ Syntax OK: {filepath}")
              except py_compile.PyCompileError as e:
                  print(f"‚ùå Syntax Error: {filepath} - {e}")
                  all_ok = False

          if not all_ok:
              print("Syntax errors detected, aborting")
              exit(1)

          SYNTAX_SCRIPT

      - name: Deploy Lambdas
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        run: |
          python3 << 'DEPLOY_SCRIPT'
          import json
          import subprocess

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          lambdas = decision.get('lambdas_to_deploy', [])
          if not lambdas:
              print("No lambdas to deploy")
              exit(0)

          deployed = 0
          for name in lambdas:
              service_dir = f"services/{name}"
              lambda_name = f"eth-trading-{name}"
              zip_path = f"/tmp/{name}.zip"

              print(f"\n=== Deploying {lambda_name} ===")

              # ZIP‰ΩúÊàê
              result = subprocess.run(
                  ['zip', '-r', '-j', zip_path, service_dir],
                  capture_output=True, text=True
              )
              if result.returncode != 0:
                  print(f"ZIP failed: {result.stderr}")
                  continue

              # „Éá„Éó„É≠„Ç§
              result = subprocess.run(
                  ['aws', 'lambda', 'update-function-code',
                   '--function-name', lambda_name,
                   '--zip-file', f'fileb://{zip_path}',
                   '--output', 'json'],
                  capture_output=True, text=True
              )
              if result.returncode != 0:
                  print(f"Deploy failed: {result.stderr}")
                  continue

              print(f"‚úÖ Deployed {lambda_name}")
              deployed += 1

          print(f"\nDeployed: {deployed}/{len(lambdas)}")
          if deployed == 0 and len(lambdas) > 0:
              exit(1)

          DEPLOY_SCRIPT

      - name: Update docs with Claude
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python3 << 'DOCS_SCRIPT'
          import json
          import os
          import urllib.request
          import glob

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          if not decision.get('doc_updates_needed', False):
              print("No doc updates needed")
              exit(0)

          # Â§âÊõ¥ÂÜÖÂÆπ„ÇíÂèéÈõÜ
          changes_desc = []
          for c in decision.get('proposed_changes', []):
              changes_desc.append(f"- {c.get('file', '')}: {c.get('description', '')}")
          changes_text = '\n'.join(changes_desc)

          commit_msg = decision.get('commit_message', '')
          improvement = decision.get('improvement_record', {})

          api_key = os.environ.get('ANTHROPIC_API_KEY', '')
          if not api_key:
              print("No API key, skipping docs")
              exit(0)

          # Èñ¢ÈÄ£„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÁâπÂÆö
          doc_paths = glob.glob('docs/*.md')
          updated = 0

          for doc_path in doc_paths:
              with open(doc_path, 'r') as f:
                  doc_content = f.read()

              # Â§âÊõ¥„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„Å´Èñ¢ÈÄ£„Åô„Çã„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ„ÅøÊõ¥Êñ∞
              changed_files = [c.get('file', '') for c in decision.get('proposed_changes', [])]
              relevant = False
              for cf in changed_files:
                  service_name = cf.split('/')[1] if '/' in cf else ''
                  if service_name and (service_name in doc_content or
                                        service_name.replace('-', '_') in doc_content):
                      relevant = True
                      break

              if not relevant:
                  continue

              prompt = f"""‰ª•‰∏ã„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„Çí„ÄÅ„Ç≥„Éº„ÉâÂ§âÊõ¥„Å´Âêà„Çè„Åõ„Å¶Êõ¥Êñ∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

## Â§âÊõ¥ÂÜÖÂÆπ
{changes_text}

## „Ç≥„Éü„ÉÉ„Éà„É°„ÉÉ„Çª„Éº„Ç∏
{commit_msg}

## ÊîπÂñÑ„ÅÆË¶ÅÁ¥Ñ
{json.dumps(improvement, ensure_ascii=False)}

## ÂØæË±°„Éâ„Ç≠„É•„É°„É≥„Éà: {doc_path}
```markdown
{doc_content}
```

ÊåáÁ§∫:
- Â§âÊõ¥„Å´Áõ¥Êé•Èñ¢‰øÇ„Åô„ÇãÁÆáÊâÄ„ÅÆ„Åø‰øÆÊ≠£
- ‰øÆÊ≠£„Åå‰∏çË¶Å„Å™„Çâ„ÄåNO_UPDATE_NEEDED„Äç„Å®„Å†„ÅëÂá∫Âäõ
- ‰øÆÊ≠£„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØ‰øÆÊ≠£Âæå„ÅÆ„Éâ„Ç≠„É•„É°„É≥„ÉàÂÖ®‰Ωì„Çí‰ª•‰∏ã„ÅÆ„Éû„Éº„Ç´„Éº„ÅßÂõ≤„Çì„ÅßÂá∫Âäõ:

---DOC_START---
Ôºà‰øÆÊ≠£Âæå„ÅÆMarkdownÂÖ®‰ΩìÔºâ
---DOC_END---
"""

              request_body = {
                  "model": "claude-sonnet-4-20250514",
                  "max_tokens": 16384,
                  "messages": [{"role": "user", "content": prompt}]
              }
              headers = {
                  "x-api-key": api_key,
                  "anthropic-version": "2023-06-01",
                  "content-type": "application/json"
              }

              try:
                  req = urllib.request.Request(
                      "https://api.anthropic.com/v1/messages",
                      data=json.dumps(request_body).encode('utf-8'),
                      headers=headers,
                      method='POST'
                  )
                  response = urllib.request.urlopen(req, timeout=240)
                  result = json.loads(response.read().decode('utf-8'))
                  content = result['content'][0]['text']

                  if 'NO_UPDATE_NEEDED' in content:
                      print(f"  {doc_path}: No update needed")
                  elif '---DOC_START---' in content and '---DOC_END---' in content:
                      updated_doc = content.split('---DOC_START---')[1].split('---DOC_END---')[0].strip()
                      if updated_doc.startswith('```markdown'):
                          updated_doc = updated_doc[len('```markdown'):].strip()
                      if updated_doc.startswith('```'):
                          updated_doc = updated_doc[3:].strip()
                      if updated_doc.endswith('```'):
                          updated_doc = updated_doc[:-3].strip()

                      with open(doc_path, 'w') as f:
                          f.write(updated_doc + '\n')
                      print(f"  ‚úÖ {doc_path}: Updated")
                      updated += 1
                  else:
                      print(f"  {doc_path}: Could not parse response")

              except Exception as e:
                  print(f"  {doc_path}: Error: {e}")

          print(f"\nDocs updated: {updated}")
          DOCS_SCRIPT

      - name: Record improvement in DynamoDB
        if: steps.decision.outputs.decision != 'NO_ACTION'
        run: |
          python3 << 'RECORD_SCRIPT'
          import json
          import boto3
          import time

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          dynamodb = boto3.resource('dynamodb', region_name='ap-northeast-1')
          table = dynamodb.Table('eth-trading-improvements')

          now = int(time.time())
          ttl = now + (180 * 86400)  # 180Êó•

          improvement = decision.get('improvement_record', {})

          item = {
              'improvement_id': f"auto-{decision.get('decision', 'unknown').lower()}-{now}",
              'timestamp': now,
              'date': "${{ steps.report.outputs.report_date }}",
              'decision': decision.get('decision', ''),
              'confidence': str(decision.get('confidence', 0)),
              'reasoning': decision.get('reasoning', ''),
              'summary': improvement.get('summary', ''),
              'changes_applied': improvement.get('changes_applied', []),
              'lambdas_deployed': decision.get('lambdas_to_deploy', []),
              'rollback_criteria': decision.get('rollback_criteria', ''),
              'proposed_changes': json.dumps(decision.get('proposed_changes', []), ensure_ascii=False)[:2000],
              'ttl': ttl
          }

          table.put_item(Item=item)
          print(f"Improvement recorded: {item['improvement_id']}")
          RECORD_SCRIPT

      - name: Commit and push
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        run: |
          COMMIT_MSG=$(jq -r '.commit_message // "improve: auto-improvement"' /tmp/decision.json)
          REASONING=$(jq -r '.reasoning // ""' /tmp/decision.json)

          git config user.name "auto-improve-bot"
          git config user.email "auto-improve-bot@users.noreply.github.com"

          git add -A
          git diff --cached --quiet && echo "No changes to commit" && exit 0

          git commit -m "${COMMIT_MSG} [bot]" -m "${REASONING}"
          git push

          echo "Changes pushed to main"

      - name: Notify Slack (result)
        if: always()
        run: |
          python3 << 'SLACK_SCRIPT'
          import json
          import urllib.request
          import os

          webhook_url = "${{ secrets.SLACK_WEBHOOK_URL }}"
          if not webhook_url:
              exit(0)

          report_date = "${{ steps.report.outputs.report_date }}"
          job_status = "${{ job.status }}"

          try:
              with open('/tmp/decision.json', 'r') as f:
                  decision = json.load(f)
          except:
              decision = {"decision": "ERROR", "reasoning": "Decision file not found"}

          d = decision.get('decision', 'ERROR')
          confidence = decision.get('confidence', 0)
          reasoning = decision.get('reasoning', 'N/A')
          slack_summary = decision.get('slack_summary', 'N/A')
          changes = decision.get('proposed_changes', [])
          lambdas = decision.get('lambdas_to_deploy', [])
          rollback = decision.get('rollback_criteria', 'N/A')

          if d == 'NO_ACTION':
              emoji = 'üü¢'
              status = 'Â§âÊõ¥‰∏çË¶Å'
              color = '#36a64f'
          elif d in ('PARAM_TUNE', 'CODE_CHANGE'):
              if job_status == 'success':
                  emoji = 'üîß'
                  status = f'{d} ÈÅ©Áî®ÂÆå‰∫Ü'
                  color = '#2196f3'
              else:
                  emoji = '‚ùå'
                  status = f'{d} ÈÅ©Áî®Â§±Êïó'
                  color = '#ff0000'
          else:
              emoji = '‚ö†Ô∏è'
              status = f'ÂàÜÊûê„Ç®„É©„Éº ({job_status})'
              color = '#ff9900'

          changes_text = ""
          if changes:
              for c in changes[:3]:
                  changes_text += f"\n  ‚Ä¢ {c.get('file','')}: {c.get('description','')}"

          lambdas_text = ', '.join(lambdas) if lambdas else '„Å™„Åó'

          text = f"""{emoji} *Auto-Improve: {report_date}*

*Âà§ÂÆö:* {status} (‰ø°È†ºÂ∫¶: {confidence:.0%})
*Ê†πÊã†:* {reasoning}
*Ë¶ÅÁ¥Ñ:* {slack_summary}
*Â§âÊõ¥:* {changes_text if changes_text else '„Å™„Åó'}
*„Éá„Éó„É≠„Ç§:* {lambdas_text}
*„É≠„Éº„É´„Éê„ÉÉ„ÇØÂü∫Ê∫ñ:* {rollback}"""

          payload = {
              "blocks": [
                  {"type": "section", "text": {"type": "mrkdwn", "text": text}}
              ]
          }

          try:
              req = urllib.request.Request(
                  webhook_url,
                  data=json.dumps(payload).encode('utf-8'),
                  headers={'Content-Type': 'application/json'}
              )
              urllib.request.urlopen(req, timeout=10)
          except Exception as e:
              print(f"Slack failed: {e}")

          SLACK_SCRIPT
