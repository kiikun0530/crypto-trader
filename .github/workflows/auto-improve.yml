name: Auto-Improve Trading Algorithm

on:
  repository_dispatch:
    types: [daily-improvement]

permissions:
  contents: write
  models: read

env:
  AWS_REGION: ap-northeast-1

jobs:
  auto-improve:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_AUTO_FIX_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Extract report
        id: report
        run: |
          cat << 'PAYLOAD_EOF' > /tmp/daily_report.json
          ${{ toJson(github.event.client_payload.report) }}
          PAYLOAD_EOF

          REPORT_DATE=$(jq -r '.date' /tmp/daily_report.json)
          TRADES_COUNT=$(jq -r '.trades.total' /tmp/daily_report.json)
          WIN_RATE=$(jq -r '.trades.win_rate' /tmp/daily_report.json)
          PNL=$(jq -r '.trades.total_pnl_jpy' /tmp/daily_report.json)

          echo "report_date=${REPORT_DATE}" >> $GITHUB_OUTPUT
          echo "=== Daily Report: ${REPORT_DATE} ==="
          echo "Trades: ${TRADES_COUNT}, Win Rate: ${WIN_RATE}, PnL: Â¥${PNL}"

      - name: Read source code for analysis
        run: |
          # åˆ†æžã«å¿…è¦ãªã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’åŽé›†
          echo "=== Collecting source files ==="

          # aggregator (é–¾å€¤ãƒ»ã‚¦ã‚§ã‚¤ãƒˆ)
          cat services/aggregator/handler.py > /tmp/aggregator.py
          echo "aggregator.py: $(wc -l < services/aggregator/handler.py) lines"

          # technical (ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™)
          cat services/technical/handler.py > /tmp/technical.py
          echo "technical.py: $(wc -l < services/technical/handler.py) lines"

          # chronos-caller (AIäºˆæ¸¬)
          cat services/chronos-caller/handler.py > /tmp/chronos.py
          echo "chronos.py: $(wc -l < services/chronos-caller/handler.py) lines"

          # news-collector (ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆ)
          cat services/news-collector/handler.py > /tmp/news.py
          echo "news.py: $(wc -l < services/news-collector/handler.py) lines"

          # market-context
          cat services/market-context/handler.py > /tmp/market_ctx.py
          echo "market_ctx.py: $(wc -l < services/market-context/handler.py) lines"

          # position-monitor (SL/TP)
          cat services/position-monitor/handler.py > /tmp/position.py
          echo "position.py: $(wc -l < services/position-monitor/handler.py) lines"

          # order-executor (æ³¨æ–‡ãƒ»ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼)
          cat services/order-executor/handler.py > /tmp/order.py
          echo "order.py: $(wc -l < services/order-executor/handler.py) lines"

          # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
          for doc in docs/*.md; do
            cp "$doc" /tmp/doc_$(basename "$doc")
          done
          echo "Docs copied: $(ls /tmp/doc_*.md | wc -l) files"

      - name: Analyze with Claude and decide
        id: claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python3 << 'CLAUDE_SCRIPT'
          import json
          import os
          import urllib.request
          import glob

          # === ãƒ¬ãƒãƒ¼ãƒˆèª­ã¿è¾¼ã¿ ===
          with open('/tmp/daily_report.json', 'r') as f:
              report = json.load(f)

          # === ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿ï¼ˆä¸»è¦éƒ¨åˆ†ã®ã¿ï¼‰ ===
          source_files = {}
          for name in ['aggregator', 'technical', 'chronos', 'news', 'market_ctx',
                       'position', 'order']:
              path = f'/tmp/{name}.py'
              if os.path.exists(path):
                  with open(path, 'r') as f:
                      content = f.read()
                  # 4000æ–‡å­—ã«åˆ¶é™ï¼ˆClaude ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç¯€ç´„ï¼‰
                  source_files[name] = content[:8000]

          # === ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆèª­ã¿è¾¼ã¿ ===
          doc_files = {}
          for path in sorted(glob.glob('/tmp/doc_*.md')):
              name = os.path.basename(path).replace('doc_', '')
              with open(path, 'r') as f:
                  doc_files[name] = f.read()[:3000]

          # === ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰ ===
          report_json = json.dumps(report, indent=2, ensure_ascii=False)

          source_summary = ""
          for name, code in source_files.items():
              source_summary += f"\n### {name}.py\n```python\n{code}\n```\n"

          prompt = f"""ã‚ãªãŸã¯æš—å·é€šè²¨ãƒˆãƒ¬ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®åˆ†æžå®˜å…¼ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã™ã€‚
æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆã‚’åˆ†æžã—ã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æ”¹å–„ãŒå¿…è¦ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã—ã¦ãã ã•ã„ã€‚

## æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆ
```json
{report_json}
```

## ç¾åœ¨ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ï¼ˆä¸»è¦ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
{source_summary}

## åˆ¤æ–­åŸºæº–

### NO_ACTIONï¼ˆå¤‰æ›´ä¸è¦ï¼‰ã®æ¡ä»¶:
- å¸‚å ´å…¨ä½“ãŒä¸€æ–¹å‘ã«å‹•ã„ãŸæ—¥ï¼ˆå…¨é€šè²¨ä¸‹è½æ™‚ã«æå¤±ã¯æ­£å¸¸ï¼‰
- æ—¥æ¬¡ãƒˆãƒ¬ãƒ¼ãƒ‰3ä»¶æœªæº€ï¼ˆçµ±è¨ˆçš„ã«ç„¡æ„å‘³ï¼‰
- 7æ—¥ãƒ­ãƒ¼ãƒªãƒ³ã‚°å‹çŽ‡ãŒ25-55%ã®ç¯„å›²ï¼ˆæ­£å¸¸å‹•ä½œï¼‰
- å€‹åˆ¥æå¤±ã®åŽŸå› ãŒå¸‚å ´æ€¥å¤‰ï¼ˆF&Gæ€¥å¤‰å‹•ã€çªç™ºãƒ‹ãƒ¥ãƒ¼ã‚¹ï¼‰
- ç›´è¿‘2é€±é–“ä»¥å†…ã«æ”¹å–„ãŒé©ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€åŠ¹æžœæ¸¬å®šã®ãŸã‚å¤‰æ›´ã‚’æŽ§ãˆã‚‹

### PARAM_TUNEï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¾®èª¿æ•´ï¼‰ã®æ¡ä»¶:
- ç‰¹å®šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®near_zeroçŽ‡ãŒ60%è¶…ï¼ˆã‚¦ã‚§ã‚¤ãƒˆå‰Šæ¸›å€™è£œï¼‰
- é–¾å€¤è¿‘è¾º (Â±0.02) ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ãŒç³»çµ±çš„ã«è² ã‘ã‚‹
- 7æ—¥ãƒ­ãƒ¼ãƒªãƒ³ã‚°å‹çŽ‡ãŒ20%æœªæº€ã§10ä»¶ä»¥ä¸Šã®ã‚µãƒ³ãƒ—ãƒ«ãŒã‚ã‚‹
- 30æ—¥ãƒ­ãƒ¼ãƒªãƒ³ã‚°ã§ä¸€è²«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç‰¹å®šé€šè²¨ãƒšã‚¢ãŒå¸¸ã«è² ã‘ã‚‹ç­‰ï¼‰

### CODE_CHANGEï¼ˆãƒ­ã‚¸ãƒƒã‚¯å¤‰æ›´ï¼‰ã®æ¡ä»¶:
- åŒä¸€ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æå¤±ãŒ3æ—¥ä»¥ä¸Šé€£ç¶šï¼ˆrecent_improvements ã§ç¢ºèªï¼‰
- ç‰¹å®šæŒ‡æ¨™ãŒä¸€è²«ã—ã¦é€†æ–¹å‘ã‚’ç¤ºã™ï¼ˆãƒ­ã‚¸ãƒƒã‚¯ãƒã‚°ã®ç–‘ã„ï¼‰
- æ–°ãŸãªå¸‚å ´ãƒ‘ã‚¿ãƒ¼ãƒ³ã¸ã®æœªå¯¾å¿œãŒæ˜Žç¢º

## å®‰å…¨ãƒ«ãƒ¼ãƒ«ï¼ˆåŽ³å®ˆï¼‰:
1. ã‚¦ã‚§ã‚¤ãƒˆå¤‰æ›´ã¯1å›žã‚ãŸã‚Š Â±0.05 ã¾ã§ã€4æˆåˆ†ã®åˆè¨ˆãŒå¿…ãš1.0
2. é–¾å€¤å¤‰æ›´ã¯1å›žã‚ãŸã‚Š Â±0.03 ã¾ã§
3. VOL_CLAMP_MIN ã¯ 0.50ã€œ1.00 ã®ç¯„å›²
4. æ—¢å­˜ã®å®‰å…¨æ©Ÿæ§‹ï¼ˆæœ€ä½Žä¿æœ‰æ™‚é–“ã€é€šè²¨åˆ†æ•£åˆ¶é™ã€ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ï¼‰ã¯å‰Šé™¤ç¦æ­¢
5. ãƒ‡ãƒ¼ã‚¿ãŒä¸ååˆ†ãªå ´åˆã¯å¿…ãš NO_ACTION
6. importæ–‡ã®è¿½åŠ ãƒ»å‰Šé™¤ã¯æ…Žé‡ã«ï¼ˆLambdaç’°å¢ƒã§ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã¿ä½¿ç”¨å¯èƒ½ã€boto3, jsonã¯å¯ï¼‰
7. éŽåŽ»ã®æ”¹å–„ã§å…¥ã‚ŒãŸãƒ­ã‚¸ãƒƒã‚¯ã‚’å®‰æ˜“ã«æ¶ˆã•ãªã„

## å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆï¼ˆåŽ³å¯†ã«JSONå½¢å¼ã§ï¼‰:

---DECISION_START---
{{
  "decision": "NO_ACTION" | "PARAM_TUNE" | "CODE_CHANGE",
  "confidence": 0.0-1.0,
  "reasoning": "åˆ¤æ–­ã®æ ¹æ‹ ï¼ˆæ—¥æœ¬èªžã€200æ–‡å­—ä»¥å†…ï¼‰",
  "statistical_evidence": {{
    "key_metric": "æ ¹æ‹ ã¨ãªã‚‹ä¸»è¦æŒ‡æ¨™",
    "value": "æŒ‡æ¨™ã®å€¤",
    "threshold": "åˆ¤æ–­åŸºæº–ã®é–¾å€¤"
  }},
  "proposed_changes": [
    {{
      "file": "services/aggregator/handler.py",
      "description": "å¤‰æ›´ã®èª¬æ˜Ž",
      "search": "å¤‰æ›´å‰ã®ã‚³ãƒ¼ãƒ‰ï¼ˆæ­£ç¢ºã«ä¸€è‡´ã™ã‚‹éƒ¨åˆ†ï¼‰",
      "replace": "å¤‰æ›´å¾Œã®ã‚³ãƒ¼ãƒ‰"
    }}
  ],
  "doc_updates_needed": true | false,
  "lambdas_to_deploy": ["aggregator"],
  "commit_message": "improve: å¤‰æ›´ã®èª¬æ˜Ž",
  "slack_summary": "Slackã«æŠ•ç¨¿ã™ã‚‹æ”¹å–„ã‚µãƒžãƒªãƒ¼ï¼ˆæ—¥æœ¬èªžã€100æ–‡å­—ä»¥å†…ï¼‰",
  "rollback_criteria": "3æ—¥ä»¥å†…ã«å‹çŽ‡ãŒX%æœªæº€ã«ä½Žä¸‹ã—ãŸå ´åˆãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯",
  "improvement_record": {{
    "summary": "æ”¹å–„ã®è¦ç´„",
    "changes_applied": ["å¤‰æ›´1", "å¤‰æ›´2"]
  }}
}}
---DECISION_END---

NO_ACTION ã®å ´åˆã¯ proposed_changes ã‚’ç©ºé…åˆ— []ã€lambdas_to_deploy ã‚’ç©ºé…åˆ— [] ã«ã—ã¦ãã ã•ã„ã€‚
"""

          # === Claude API å‘¼ã³å‡ºã— ===
          api_key = os.environ.get('ANTHROPIC_API_KEY', '')
          if not api_key:
              print("ERROR: No Anthropic API key")
              # NO_ACTION ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã¦æ›¸ãå‡ºã—
              decision = {"decision": "NO_ACTION", "confidence": 0, "reasoning": "API key missing"}
              with open('/tmp/decision.json', 'w') as f:
                  json.dump(decision, f)
              exit(0)

          request_body = {
              "model": "claude-sonnet-4-20250514",
              "max_tokens": 8192,
              "messages": [{"role": "user", "content": prompt}]
          }
          headers = {
              "x-api-key": api_key,
              "anthropic-version": "2023-06-01",
              "content-type": "application/json"
          }

          req = urllib.request.Request(
              "https://api.anthropic.com/v1/messages",
              data=json.dumps(request_body).encode('utf-8'),
              headers=headers,
              method='POST'
          )

          try:
              response = urllib.request.urlopen(req, timeout=300)
              result = json.loads(response.read().decode('utf-8'))
              content = result['content'][0]['text']
              print("=== Claude Response ===")
              print(content[:1000])

              # Decision JSON æŠ½å‡º
              if '---DECISION_START---' in content and '---DECISION_END---' in content:
                  decision_str = content.split('---DECISION_START---')[1].split('---DECISION_END---')[0].strip()
                  # JSONãƒ–ãƒ­ãƒƒã‚¯å†…ã®ã‚³ãƒ¼ãƒ‰ãƒ•ã‚§ãƒ³ã‚¹ã‚’é™¤åŽ»
                  if decision_str.startswith('```json'):
                      decision_str = decision_str[7:]
                  if decision_str.startswith('```'):
                      decision_str = decision_str[3:]
                  if decision_str.endswith('```'):
                      decision_str = decision_str[:-3]
                  decision_str = decision_str.strip()

                  decision = json.loads(decision_str)
                  with open('/tmp/decision.json', 'w') as f:
                      json.dump(decision, f, indent=2, ensure_ascii=False)
                  print(f"\nDecision: {decision['decision']}")
                  print(f"Confidence: {decision.get('confidence', 0)}")
                  print(f"Reasoning: {decision.get('reasoning', '')}")
              else:
                  print("ERROR: Could not extract decision from Claude response")
                  decision = {"decision": "NO_ACTION", "confidence": 0,
                              "reasoning": "Claudeå¿œç­”ã‹ã‚‰Decisionã‚’æŠ½å‡ºã§ããªã‹ã£ãŸ"}
                  with open('/tmp/decision.json', 'w') as f:
                      json.dump(decision, f)

          except Exception as e:
              print(f"Claude API error: {e}")
              decision = {"decision": "NO_ACTION", "confidence": 0,
                          "reasoning": f"Claude API error: {str(e)[:200]}"}
              with open('/tmp/decision.json', 'w') as f:
                  json.dump(decision, f)

          CLAUDE_SCRIPT

      - name: Parse decision
        id: decision
        run: |
          DECISION=$(jq -r '.decision' /tmp/decision.json)
          CONFIDENCE=$(jq -r '.confidence' /tmp/decision.json)
          REASONING=$(jq -r '.reasoning' /tmp/decision.json)
          SLACK_SUMMARY=$(jq -r '.slack_summary // "N/A"' /tmp/decision.json)
          COMMIT_MSG=$(jq -r '.commit_message // "improve: auto-improvement"' /tmp/decision.json)
          DEPLOY_COUNT=$(jq '.lambdas_to_deploy | length' /tmp/decision.json)

          echo "decision=${DECISION}" >> $GITHUB_OUTPUT
          echo "confidence=${CONFIDENCE}" >> $GITHUB_OUTPUT
          echo "deploy_count=${DEPLOY_COUNT}" >> $GITHUB_OUTPUT

          echo "=== Decision ==="
          echo "Decision: ${DECISION}"
          echo "Confidence: ${CONFIDENCE}"
          echo "Reasoning: ${REASONING}"
          echo "Lambdas to deploy: ${DEPLOY_COUNT}"

      - name: Apply code changes
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        run: |
          python3 << 'APPLY_SCRIPT'
          import json

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          changes = decision.get('proposed_changes', [])
          if not changes:
              print("No changes to apply")
              exit(0)

          applied = 0
          failed = 0

          for change in changes:
              filepath = change.get('file', '')
              search = change.get('search', '')
              replace = change.get('replace', '')
              description = change.get('description', '')

              if not filepath or not search:
                  print(f"Skipping invalid change: {description}")
                  failed += 1
                  continue

              try:
                  with open(filepath, 'r') as f:
                      content = f.read()

                  if search not in content:
                      print(f"WARNING: Search string not found in {filepath}")
                      print(f"  Search: {search[:100]}...")
                      failed += 1
                      continue

                  # æ­£ç¢ºã«1ç®‡æ‰€ã ã‘ç½®æ›
                  count = content.count(search)
                  if count != 1:
                      print(f"WARNING: Search string found {count} times in {filepath}, expected 1")
                      failed += 1
                      continue

                  new_content = content.replace(search, replace, 1)
                  with open(filepath, 'w') as f:
                      f.write(new_content)

                  print(f"âœ… Applied: {filepath} - {description}")
                  applied += 1

              except Exception as e:
                  print(f"âŒ Failed: {filepath} - {e}")
                  failed += 1

          print(f"\nApplied: {applied}, Failed: {failed}")

          if applied == 0 and len(changes) > 0:
              print("ERROR: No changes were applied")
              exit(1)

          APPLY_SCRIPT

      - name: Syntax check
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        run: |
          python3 << 'SYNTAX_SCRIPT'
          import json
          import py_compile

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          files = set()
          for change in decision.get('proposed_changes', []):
              f = change.get('file', '')
              if f and f.endswith('.py'):
                  files.add(f)

          all_ok = True
          for filepath in files:
              try:
                  py_compile.compile(filepath, doraise=True)
                  print(f"âœ… Syntax OK: {filepath}")
              except py_compile.PyCompileError as e:
                  print(f"âŒ Syntax Error: {filepath} - {e}")
                  all_ok = False

          if not all_ok:
              print("Syntax errors detected, aborting")
              exit(1)

          SYNTAX_SCRIPT

      - name: Deploy Lambdas
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        run: |
          python3 << 'DEPLOY_SCRIPT'
          import json
          import subprocess

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          lambdas = decision.get('lambdas_to_deploy', [])
          if not lambdas:
              print("No lambdas to deploy")
              exit(0)

          deployed = 0
          for name in lambdas:
              service_dir = f"services/{name}"
              lambda_name = f"eth-trading-{name}"
              zip_path = f"/tmp/{name}.zip"

              print(f"\n=== Deploying {lambda_name} ===")

              # ZIPä½œæˆ
              result = subprocess.run(
                  ['zip', '-r', '-j', zip_path, service_dir],
                  capture_output=True, text=True
              )
              if result.returncode != 0:
                  print(f"ZIP failed: {result.stderr}")
                  continue

              # ãƒ‡ãƒ—ãƒ­ã‚¤
              result = subprocess.run(
                  ['aws', 'lambda', 'update-function-code',
                   '--function-name', lambda_name,
                   '--zip-file', f'fileb://{zip_path}',
                   '--output', 'json'],
                  capture_output=True, text=True
              )
              if result.returncode != 0:
                  print(f"Deploy failed: {result.stderr}")
                  continue

              print(f"âœ… Deployed {lambda_name}")
              deployed += 1

          print(f"\nDeployed: {deployed}/{len(lambdas)}")
          if deployed == 0 and len(lambdas) > 0:
              exit(1)

          DEPLOY_SCRIPT

      - name: Update docs with Claude
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python3 << 'DOCS_SCRIPT'
          import json
          import os
          import urllib.request
          import glob

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          if not decision.get('doc_updates_needed', False):
              print("No doc updates needed")
              exit(0)

          # å¤‰æ›´å†…å®¹ã‚’åŽé›†
          changes_desc = []
          for c in decision.get('proposed_changes', []):
              changes_desc.append(f"- {c.get('file', '')}: {c.get('description', '')}")
          changes_text = '\n'.join(changes_desc)

          commit_msg = decision.get('commit_message', '')
          improvement = decision.get('improvement_record', {})

          api_key = os.environ.get('ANTHROPIC_API_KEY', '')
          if not api_key:
              print("No API key, skipping docs")
              exit(0)

          # é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç‰¹å®š
          doc_paths = glob.glob('docs/*.md')
          updated = 0

          for doc_path in doc_paths:
              with open(doc_path, 'r') as f:
                  doc_content = f.read()

              # å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã«é–¢é€£ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã¿æ›´æ–°
              changed_files = [c.get('file', '') for c in decision.get('proposed_changes', [])]
              relevant = False
              for cf in changed_files:
                  service_name = cf.split('/')[1] if '/' in cf else ''
                  if service_name and (service_name in doc_content or
                                        service_name.replace('-', '_') in doc_content):
                      relevant = True
                      break

              if not relevant:
                  continue

              prompt = f"""ä»¥ä¸‹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ã€ã‚³ãƒ¼ãƒ‰å¤‰æ›´ã«åˆã‚ã›ã¦æ›´æ–°ã—ã¦ãã ã•ã„ã€‚

## å¤‰æ›´å†…å®¹
{changes_text}

## ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
{commit_msg}

## æ”¹å–„ã®è¦ç´„
{json.dumps(improvement, ensure_ascii=False)}

## å¯¾è±¡ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: {doc_path}
```markdown
{doc_content}
```

æŒ‡ç¤º:
- å¤‰æ›´ã«ç›´æŽ¥é–¢ä¿‚ã™ã‚‹ç®‡æ‰€ã®ã¿ä¿®æ­£
- ä¿®æ­£ãŒä¸è¦ãªã‚‰ã€ŒNO_UPDATE_NEEDEDã€ã¨ã ã‘å‡ºåŠ›
- ä¿®æ­£ãŒå¿…è¦ãªå ´åˆã¯ä¿®æ­£å¾Œã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå…¨ä½“ã‚’ä»¥ä¸‹ã®ãƒžãƒ¼ã‚«ãƒ¼ã§å›²ã‚“ã§å‡ºåŠ›:

---DOC_START---
ï¼ˆä¿®æ­£å¾Œã®Markdownå…¨ä½“ï¼‰
---DOC_END---
"""

              request_body = {
                  "model": "claude-sonnet-4-20250514",
                  "max_tokens": 16384,
                  "messages": [{"role": "user", "content": prompt}]
              }
              headers = {
                  "x-api-key": api_key,
                  "anthropic-version": "2023-06-01",
                  "content-type": "application/json"
              }

              try:
                  req = urllib.request.Request(
                      "https://api.anthropic.com/v1/messages",
                      data=json.dumps(request_body).encode('utf-8'),
                      headers=headers,
                      method='POST'
                  )
                  response = urllib.request.urlopen(req, timeout=240)
                  result = json.loads(response.read().decode('utf-8'))
                  content = result['content'][0]['text']

                  if 'NO_UPDATE_NEEDED' in content:
                      print(f"  {doc_path}: No update needed")
                  elif '---DOC_START---' in content and '---DOC_END---' in content:
                      updated_doc = content.split('---DOC_START---')[1].split('---DOC_END---')[0].strip()
                      if updated_doc.startswith('```markdown'):
                          updated_doc = updated_doc[len('```markdown'):].strip()
                      if updated_doc.startswith('```'):
                          updated_doc = updated_doc[3:].strip()
                      if updated_doc.endswith('```'):
                          updated_doc = updated_doc[:-3].strip()

                      with open(doc_path, 'w') as f:
                          f.write(updated_doc + '\n')
                      print(f"  âœ… {doc_path}: Updated")
                      updated += 1
                  else:
                      print(f"  {doc_path}: Could not parse response")

              except Exception as e:
                  print(f"  {doc_path}: Error: {e}")

          print(f"\nDocs updated: {updated}")
          DOCS_SCRIPT

      - name: Record improvement in DynamoDB
        if: steps.decision.outputs.decision != 'NO_ACTION'
        run: |
          python3 << 'RECORD_SCRIPT'
          import json
          import boto3
          import time

          with open('/tmp/decision.json', 'r') as f:
              decision = json.load(f)

          dynamodb = boto3.resource('dynamodb', region_name='ap-northeast-1')
          table = dynamodb.Table('eth-trading-improvements')

          now = int(time.time())
          ttl = now + (180 * 86400)  # 180æ—¥

          improvement = decision.get('improvement_record', {})

          item = {
              'improvement_id': f"auto-{decision.get('decision', 'unknown').lower()}-{now}",
              'timestamp': now,
              'date': "${{ steps.report.outputs.report_date }}",
              'decision': decision.get('decision', ''),
              'confidence': str(decision.get('confidence', 0)),
              'reasoning': decision.get('reasoning', ''),
              'summary': improvement.get('summary', ''),
              'changes_applied': improvement.get('changes_applied', []),
              'lambdas_deployed': decision.get('lambdas_to_deploy', []),
              'rollback_criteria': decision.get('rollback_criteria', ''),
              'proposed_changes': json.dumps(decision.get('proposed_changes', []), ensure_ascii=False)[:2000],
              'ttl': ttl
          }

          table.put_item(Item=item)
          print(f"Improvement recorded: {item['improvement_id']}")
          RECORD_SCRIPT

      - name: Commit and push
        if: steps.decision.outputs.decision != 'NO_ACTION' && steps.decision.outputs.deploy_count != '0'
        run: |
          COMMIT_MSG=$(jq -r '.commit_message // "improve: auto-improvement"' /tmp/decision.json)
          REASONING=$(jq -r '.reasoning // ""' /tmp/decision.json)

          git config user.name "auto-improve-bot"
          git config user.email "auto-improve-bot@users.noreply.github.com"

          git add -A
          git diff --cached --quiet && echo "No changes to commit" && exit 0

          git commit -m "${COMMIT_MSG} [bot]" -m "${REASONING}"
          git push

          echo "Changes pushed to main"

      - name: Notify Slack (result)
        if: always()
        run: |
          python3 << 'SLACK_SCRIPT'
          import json
          import urllib.request
          import os

          webhook_url = "${{ secrets.SLACK_WEBHOOK_URL }}"
          if not webhook_url:
              exit(0)

          report_date = "${{ steps.report.outputs.report_date }}"
          job_status = "${{ job.status }}"

          try:
              with open('/tmp/decision.json', 'r') as f:
                  decision = json.load(f)
          except:
              decision = {"decision": "ERROR", "reasoning": "Decision file not found"}

          d = decision.get('decision', 'ERROR')
          confidence = decision.get('confidence', 0)
          reasoning = decision.get('reasoning', 'N/A')
          slack_summary = decision.get('slack_summary', 'N/A')
          changes = decision.get('proposed_changes', [])
          lambdas = decision.get('lambdas_to_deploy', [])
          rollback = decision.get('rollback_criteria', 'N/A')

          if d == 'NO_ACTION':
              emoji = 'ðŸŸ¢'
              status = 'å¤‰æ›´ä¸è¦'
              color = '#36a64f'
          elif d in ('PARAM_TUNE', 'CODE_CHANGE'):
              if job_status == 'success':
                  emoji = 'ðŸ”§'
                  status = f'{d} é©ç”¨å®Œäº†'
                  color = '#2196f3'
              else:
                  emoji = 'âŒ'
                  status = f'{d} é©ç”¨å¤±æ•—'
                  color = '#ff0000'
          else:
              emoji = 'âš ï¸'
              status = f'åˆ†æžã‚¨ãƒ©ãƒ¼ ({job_status})'
              color = '#ff9900'

          changes_text = ""
          if changes:
              for c in changes[:3]:
                  changes_text += f"\n  â€¢ {c.get('file','')}: {c.get('description','')}"

          lambdas_text = ', '.join(lambdas) if lambdas else 'ãªã—'

          text = f"""{emoji} *Auto-Improve: {report_date}*

*åˆ¤å®š:* {status} (ä¿¡é ¼åº¦: {confidence:.0%})
*æ ¹æ‹ :* {reasoning}
*è¦ç´„:* {slack_summary}
*å¤‰æ›´:* {changes_text if changes_text else 'ãªã—'}
*ãƒ‡ãƒ—ãƒ­ã‚¤:* {lambdas_text}
*ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯åŸºæº–:* {rollback}"""

          payload = {
              "blocks": [
                  {"type": "section", "text": {"type": "mrkdwn", "text": text}}
              ]
          }

          try:
              req = urllib.request.Request(
                  webhook_url,
                  data=json.dumps(payload).encode('utf-8'),
                  headers={'Content-Type': 'application/json'}
              )
              urllib.request.urlopen(req, timeout=10)
          except Exception as e:
              print(f"Slack failed: {e}")

          SLACK_SCRIPT
